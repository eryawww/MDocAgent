{
  "config":{
    "query_token_id":"[unused0]",
    "doc_token_id":"[unused1]",
    "query_token":"[Q]",
    "doc_token":"[D]",
    "ncells":null,
    "centroid_score_threshold":null,
    "ndocs":null,
    "load_index_with_mmap":false,
    "index_path":null,
    "index_bsize":32,
    "nbits":4,
    "kmeans_niters":20,
    "resume":false,
    "pool_factor":1,
    "clustering_mode":"hierarchical",
    "protected_tokens":0,
    "similarity":"cosine",
    "bsize":64,
    "accumsteps":1,
    "lr":0.00001,
    "maxsteps":400000,
    "save_every":null,
    "warmup":20000,
    "warmup_bert":null,
    "relu":false,
    "nway":64,
    "use_ib_negatives":true,
    "reranker":false,
    "distillation_alpha":1.0,
    "ignore_scores":false,
    "model_name":null,
    "query_maxlen":32,
    "attend_to_mask_tokens":false,
    "interaction":"colbert",
    "dim":128,
    "doc_maxlen":256,
    "mask_punctuation":true,
    "checkpoint":"colbert-ir/colbertv2.0",
    "triples":"/future/u/okhattab/root/unit/experiments/2021.10/downstream.distillation.round2.2_score/round2.nway6.cosine.ib/examples.64.json",
    "collection":[
      "Noname manuscript No. (will be inserted by the editor) Fast Multi-language LSTM-based Online Handwriting Recognition Victor Carbune \u00b7 Pedro Gonnet \u00b7 Thomas Deselaers \u00b7 Henry A. Rowley \u00b7 Alexander Daryin \u00b7 Marcos Calvo \u00b7 Li-Lun Wang \u00b7 Daniel Keysers \u00b7 Sandro Feuz \u00b7 Philippe Gervais Received: Nov. 2018 / Accepted: - Abstract We describe an online handwriting system that is able to support 102 languages using a deep neu- ral network architecture. This new system has com- pletely replaced our previous Segment-and-Decode-based system and reduced the error rate by 20%-40% relative for most languages. Further, we report new state-of- the-art results on IAM-OnDB for both the open and closed dataset setting. The system combines methods from sequence recognition with a new input encoding using B\u00e9zier curves. This leads to up to 10x faster recog- nition times compared to our previous system. Through a series of experiments we determine the optimal con- \ufb01guration of our models and report the results of our setup on a number of additional public datasets.",
      "This leads to up to 10x faster recog- nition times compared to our previous system. Through a series of experiments we determine the optimal con- \ufb01guration of our models and report the results of our setup on a number of additional public datasets. 1 Introduction In this paper we discuss online handwriting recognition: Given a user input in the form of an ink, i.e. a list of touch or pen strokes, output the textual interpretation of this input. A stroke is a sequence of points (x, y, t) with position (x, y) and timestamp t. Figure 1 illustrates example inputs to our online handwriting recognition system in di\ufb00erent languages and scripts. The left column shows examples in En- glish with di\ufb00erent writing styles, with di\ufb00erent types of content, and that may be written on one or mul- tiple lines. The center column shows examples from \ufb01ve di\ufb00erent alphabetic languages similar in structure to English: German, Russian, Vietnamese, Greek, and Georgian.",
      "The center column shows examples from \ufb01ve di\ufb00erent alphabetic languages similar in structure to English: German, Russian, Vietnamese, Greek, and Georgian. The right column shows scripts that are sig- ni\ufb01cantly di\ufb00erent from English: Chinese has a much larger set of more complex characters, and users often overlap characters with one another. Korean, while an All authors are with Google AI Perception E-mail: {vcarbune, gonnet, deselaers, har, shurick, marcoscalvo, llwang, keysers, sfeuz, pgervais}@google.com Fig. 1 Example inputs for online handwriting recognition in dif- ferent languages. See text for details. alphabetic language, groups letters in syllables leading to a large \u201calphabet\u201d of syllables. Hindi writing often contains a connecting \u2018Shirorekha\u2019 line and characters can form larger structures (grapheme clusters) which in\ufb02uence the written shape of the components.",
      "alphabetic language, groups letters in syllables leading to a large \u201calphabet\u201d of syllables. Hindi writing often contains a connecting \u2018Shirorekha\u2019 line and characters can form larger structures (grapheme clusters) which in\ufb02uence the written shape of the components. Arabic is written right-to-left (with embedded left-to-right se- quences used for numbers or English names) and char- acters change shape depending on their position within a word. Emoji are non-text Unicode symbols that we also recognize. Online handwriting recognition has recently been gaining importance for multiple reasons: (a) An increas- ing number of people in emerging markets are obtain- ing access to computing devices, many exclusively using mobile devices with touchscreens. Many of these users have native languages and scripts that are not as easily typed as English, e.g. due to the size of the alphabet or the use of grapheme clusters which makes it di\ufb03cult to design an intuitive keyboard layout [10]. (b) More and more large mobile devices with styluses are becom- arXiv:1902.10525v2  [cs.CL]  24 Jan 2020",
      "2 Victor Carbune et al. ing available, such as the iPad Pro1, Microsoft Surface devices2, and Chromebooks with styluses3. Early work in online handwriting recognition looked at segment-and-decode classi\ufb01ers, such as the Newton [48]. Another line of work [38] focused on solving online handwriting recognition by making use of Hidden Mar- kov Models (HMMs) [20] or hybrid approaches combin- ing HMMs and Feed-forward Neural Networks [2]. The \ufb01rst HMM-free models were based on Time Delay Neu- ral Networks (TDNNs) [5,22,37], and more recent work focuses on Recurrent Neural Network (RNN) variants such as Long-Short-Term-Memory networks (LSTMs) [6,7,14]. How to represent online handwriting data has been a research topic for a long time. Early approaches were feature-based, where each point is represented using a set of features [22, 23, 48], or using global features to represent entire characters [22].",
      "How to represent online handwriting data has been a research topic for a long time. Early approaches were feature-based, where each point is represented using a set of features [22, 23, 48], or using global features to represent entire characters [22]. More recently, the deep learning revolution has swept away most feature engi- neering e\ufb00orts and replaced them with learned repre- sentations in many domains, e.g. speech [17], computer vision [44], and natural language processing [33]. Together with architecture changes, training method- ologies also changed, moving from relying on explicit segmentation [25, 37, 48] to implicit segmentation us- ing the Connectionist Temporal Classi\ufb01cation (CTC) loss [12], or Encoder-Decoder approaches trained with Maximum Likelihood Estimation [51]. Further recent work is also described in [26]. The transition to more complex network architec- tures and end-to-end training can be associated with breakthroughs in related \ufb01elds focused on sequence un- derstanding where deep learning methods have outper- formed \u201ctraditional\u201d pattern recognition methods, e.g.",
      "The transition to more complex network architec- tures and end-to-end training can be associated with breakthroughs in related \ufb01elds focused on sequence un- derstanding where deep learning methods have outper- formed \u201ctraditional\u201d pattern recognition methods, e.g. in speech recognition [40,41], OCR [8,47], o\ufb04ine hand- writing recognition [16], and computer vision [45]. In this paper we describe our new online handwrit- ing recognition system based on deep learning meth- ods. It replaces our previous segment-and-decode sys- tem [25], which \ufb01rst over-segments the ink, then groups the segments into character hypotheses, and computes features for each character hypothesis which are then classi\ufb01ed as characters using a rather shallow neural network. The recognition result is then obtained using a best path search decoding algorithm on the lattice of hypotheses incorporating additional knowledge sources such as language models. This system relies on numer- ous pre-processing, segmentation, and feature extrac- tion heuristics which are no longer present in our new system.",
      "The recognition result is then obtained using a best path search decoding algorithm on the lattice of hypotheses incorporating additional knowledge sources such as language models. This system relies on numer- ous pre-processing, segmentation, and feature extrac- tion heuristics which are no longer present in our new system. The new system reduces the amount of cus- tomization required, and consists of a simple stack of bidirectional LSTMs (BLSTMs), a single Logits layer, 1 https://www.apple.com/ipad-pro/ 2 https://www.microsoft.com/en-us/store/b/surface 3 https://store.google.com/product/google_pixelbook Table 1 List of languages supported in our system grouped by script. Script Languages Latin Afrikaans, Azerbaijani, Bosnian, Catalan, Cebuano, Corsican, Czech, Welsh, Danish, German, English, Esperanto, Spanish, Estonian, Basque, Finnish, Filipino, French, Western Frisian, Irish, Scot- tish Gaelic, Galician, Hawaiian, Hmong, Croatian, Haitian Creole, Hungarian, Indonesian, Icelandic, Italian, Javanese, Kurdish, Latin, Luxembourgish, Lao, Lithuanian,",
      "Basque, Finnish, Filipino, French, Western Frisian, Irish, Scot- tish Gaelic, Galician, Hawaiian, Hmong, Croatian, Haitian Creole, Hungarian, Indonesian, Icelandic, Italian, Javanese, Kurdish, Latin, Luxembourgish, Lao, Lithuanian, Latvian, Malagasy, Maori, Malay, Maltese, Norwegian, Dutch, Nyanja, Polish, Por- tuguese, Romanian, Slovak, Slovenian, Samoan, Shona, Somali, Albanian, Sundanese, Swedish, Swahili, Turkish, Xhosa, Zulu Cyrillic Russian, Belarusian, Bulgarian, Kazakh, Mongolian, Serbian, Ukrainian, Uzbek, Macedonian, Kyrgyz, Tajik Chinese Simpli\ufb01ed Chinese, Traditional Chinese, Cantonese Arabic Arabic, Persian, Urdu Devanagari Hindi, Marathi, Nepali Bengali Bangla, Assamese Ethiopic Amharic, Tigrinya Languages with distinct scripts: Armenian, Burmese, Georgian, Greek, Gujarati, Hebrew, Japanese, Kannada, Khmer, Korean, Lao, Malayalam, Odia, Punjabi, Sinhala,",
      "Assamese Ethiopic Amharic, Tigrinya Languages with distinct scripts: Armenian, Burmese, Georgian, Greek, Gujarati, Hebrew, Japanese, Kannada, Khmer, Korean, Lao, Malayalam, Odia, Punjabi, Sinhala, Tamil, Telugu, Thai, Ti- betan, Vietnamese4 and the CTC loss [15] (Sec. 2). We train a separate model for each script (Sec. 3). To support potentially many languages per script (see Table 1), language-speci\ufb01c language models and feature functions are used during decoding (Sec. 2.5). E.g. we have a single recognition model for Arabic script which is combined with speci\ufb01c language models and feature functions for our Arabic, Persian, and Urdu language recognizers. Table 1 shows the full list of scripts and languages that we currently support. The new models are more accurate (Sec. 4), smaller, and faster (Table 9) than our previous segment-and- decode models and eliminate the need for a large num- ber of engineered features and heuristics.",
      "The new models are more accurate (Sec. 4), smaller, and faster (Table 9) than our previous segment-and- decode models and eliminate the need for a large num- ber of engineered features and heuristics. We present an extensive comparison of the di\ufb00er- ences in recognition accuracy for eight languages (Sec. 5) and compare the accuracy of models trained on publicly available datasets where available (Sec. 4). In addition, we propose a new standard experimental protocol for the IBM-UB-1 dataset [43] to enable easier comparison between approaches in the future (Sec. 4.2). The main contributions of our paper are as follows: \u2013 We describe in detail our recurrent neural network- based recognition stack and provide a description of how we tuned the model. We also provide a de- tailed experimental comparison with the previous segment-and-decode based stack [25] on the sup- ported languages. 4 While Vietnamese is a Latin script language, we have a ded- icated model for it because of the large amount of diacritics not used in other Latin script languages.",
      "Fast Multi-language LSTM-based Online Handwriting Recognition 3 \u2013 We describe a novel input representation based on B\u00e9zier curve interpolation, which produces shorter input sequences, which results in faster recognitions. \u2013 Our system achieves a new state-of-the-art on the IAM-OnDB dataset, both for open and closed train- ing sets. \u2013 We introduce an evaluation protocol for the less commonly-used English IBM-UB-1 query dataset. We provide experimental results that quantify the structural di\ufb00erence between IBM-UB-1, IAM-OnDB, and our internal dataset. \u2013 We perform ablation studies and report results on numerous experiments highlighting the contributions of the individual components of the new recognition stack on our internal datasets. 2 End-to-end Model Architecture Our handwriting recognition model draws its inspira- tion from research aimed at building end-to-end tran- scription models in the context of handwriting recogni- tion [15], optical character recognition [8], and acous- tic modeling in speech recognition [40]. The model ar- chitecture is constructed from common neural network blocks, i.e. bidirectional LSTMs and fully-connected lay- ers (Figure 2).",
      "The model ar- chitecture is constructed from common neural network blocks, i.e. bidirectional LSTMs and fully-connected lay- ers (Figure 2). It is trained in an end-to-end manner using the CTC loss [15]. Our architecture is similar to what is often used in the context of acoustic modeling for speech recogni- tion [41], in which it is referred to as a CLDNN (Con- volutions, LSTMs, and DNNs), yet we di\ufb00er from it in four points. Firstly, we do not use convolution layers, which in our own experience do not add value for large networks trained on large datasets of relatively short (compared to speech input) sequences typically seen in handwriting recognition. Secondly, we use bidirectional LSTMs, which due to latency constraints is not feasible in speech recognition systems. Thirdly, our architecture does not make use of additional fully-connected layers before and after the bidirectional LSTM layers. And \ufb01nally, we train our system using the CTC loss, as op- posed to the HMMs used in [41].",
      "Thirdly, our architecture does not make use of additional fully-connected layers before and after the bidirectional LSTM layers. And \ufb01nally, we train our system using the CTC loss, as op- posed to the HMMs used in [41]. This structure makes many components of our pre- vious system [25] unnecessary, e.g. feature extraction and segmentation. The heuristics that were hard-coded into our previous system, e.g. stroke-reordering and char- acter hypothesis building, are now implicitly learned from the training data. The model takes as input a time series (v1, . . . , vT ) of length T encoding the user input (Sec. 2.1) and passes it through several bidirectional LSTM layers [42] which learn the structure of characters (Sec. 2.2). The output of the \ufb01nal LSTM layer is passed through a softmax layer (Sec. 2.3) leading to a sequence of prob- ability distributions over characters for each time step. For CTC decoding (Sec.",
      "2.2). The output of the \ufb01nal LSTM layer is passed through a softmax layer (Sec. 2.3) leading to a sequence of prob- ability distributions over characters for each time step. For CTC decoding (Sec. 3.1) we use beam search to combine the softmax outputs with character-based language models, word-based language models, and in- formation about language-speci\ufb01c characters as in our previous system [25]. 2.1 Input Representation In our earlier paper [25] we presented results on our datasets with a model similar to the one proposed in [15]. In that model we used 23 per-point features (sim- ilarly to [22]) as described in our segment-and-decode system to represent the input. In further experimenta- tion we found that in substantially deeper and wider models, engineered features are unnecessary and their removal leads to better results. This con\ufb01rms the ob- servation that learned representations often outperform handcrafted features in scenarios in which su\ufb03cient train- ing data is available, e.g. in computer vision [28] and in speech recognition [46].",
      "This con\ufb01rms the ob- servation that learned representations often outperform handcrafted features in scenarios in which su\ufb03cient train- ing data is available, e.g. in computer vision [28] and in speech recognition [46]. In the experiments presented here, we use two representations: 2.1.1 Raw Touch Points The simplest representation of stroke data is as a se- quence of touch points. In our current system, we use a sequence of 5-dimensional points (xi, yi, ti, pi, ni) where (xi, yi) are the coordinates of the ith touchpoint, ti is the timestamp of the touchpoint since the \ufb01rst touch point in the current observation in seconds, pi indicates whether the point corresponds to a pen-up (pi = 0) or pen-down (pi = 1) stroke, and ni = 1 indicates the start of a new stroke (ni = 0 otherwise).5 In order to keep the system as \ufb02exible as possible with respect to di\ufb00erences in the writing surface, e.g.",
      "area shape, size, spatial resolution, and sampling rate, we perform some minimal preprocessing: \u2013 Normalization of xi and yi coordinates, by shifting in x such that x0 = 0, and shifting and scaling the writing area isometrically such that the y coordinate spans the range between 0 and 1. In cases where the bounding box of the writing area is unknown we use a surrogate area 20% larger than the observed range of touch points. \u2013 Equidistant linear resampling along the strokes with \u03b4 = 0.05, i.e. a line of length 1 will have 20 points. We do not assume that words are written on a \ufb01xed baseline or that the input is horizontal. As in [15], we use the di\ufb00erences between consecutive points for the 5 We acknowledge a redundancy between the features pi and ni which evolved over time from experimenting with explicit pres- sure data. We did not perform additional experiments to avoid this redundancy at this time but do not expect a large change in results when dropping either of these features.",
      "4 Victor Carbune et al. softmax bi-directional recurrent layers input Fig. 2 An overview our recognition models. In our architecture the input representation is passed through one or more bidirectional LSTM layers, and a \ufb01nal softmax layer makes a classi\ufb01cation decision for the output at each time step. (x, y) coordinates and the time t such that our input sequence is (xi\u2212xi\u22121, yi\u2212yi\u22121, ti\u2212ti\u22121, pi, ni) for i > 0, and (0, 0, 0, p0, n0) for i = 0. 2.1.2 B\u00e9zier Curves However simple, the raw input data has some draw- backs, i.e. \u2013 Resolution: Not all input devices sample inputs at the same rate, resulting in di\ufb00erent point densities along the input strokes, requiring resampling which may inadvertently normalize-out details in the in- put. \u2013 Length: We choose the (re-)sampling rate such as to represent the smallest features well, which leads to over-sampling in less interesting parts of the stroke, e.g. in straight lines.",
      "\u2013 Length: We choose the (re-)sampling rate such as to represent the smallest features well, which leads to over-sampling in less interesting parts of the stroke, e.g. in straight lines. \u2013 Model complexity: The model has to learn to map small consecutive steps to larger global features. B\u00e9zier curves are a natural way to describe trajecto- ries in space, and have been used to represent online handwriting data in the past, yet mostly as a means of removing outliers in the input data [21], up-sampling sparse data [22], or for rendering handwriting data smoothly on a screen [35]. Since a sequence of B\u00e9zier curves can represent a potentially long point sequence compactly, irrespective of the original sampling rate, we propose to represent a sequence of input points as a sequence of parametric cubic polynomials, and to use these as inputs to the recognition model.",
      "Since a sequence of B\u00e9zier curves can represent a potentially long point sequence compactly, irrespective of the original sampling rate, we propose to represent a sequence of input points as a sequence of parametric cubic polynomials, and to use these as inputs to the recognition model. These B\u00e9zier curves for x, y, and t are cubic poly- nomials in s \u2208[0, 1]: x(s) = \u03b10 + \u03b11s + \u03b12s2 + \u03b13s3 y(s) = \u03b20 + \u03b21s + \u03b22s2 + \u03b23s3 t(s) = \u03b30 + \u03b31s + \u03b32s2 + \u03b33s3 (1) We start by normalizing the size of the entire ink such that the y values are within the range [0, 1], similar to how we process it for raw points. The time values are scaled linearly to match the length of the ink such that tN\u22121 \u2212t0 = N\u22121 X i=1 \u0002 (xi \u2212xi\u22121)2 + (yi \u2212yi\u22121)2\u00031/2 .",
      "The time values are scaled linearly to match the length of the ink such that tN\u22121 \u2212t0 = N\u22121 X i=1 \u0002 (xi \u2212xi\u22121)2 + (yi \u2212yi\u22121)2\u00031/2 . (2) in order to obtain values in the same numerical range as x and y. This sets the time di\ufb00erence between the \ufb01rst and last point of the stroke to be equal to the total spatial length of the stroke. For each stroke in an ink, the coe\ufb03cients \u03b1, \u03b2, and \u03b3 are computed by minimizing the sum of squared er- rors (SSE) between each observed point i and its cor- responding closest point (de\ufb01ned by si) on the B\u00e9zier curve: N\u22121 X i=0 (xi \u2212x(si))2 + (yi \u2212y(si))2 + (ti \u2212t(si))2 . (3) Where N is the number of points in the stroke.",
      "(3) Where N is the number of points in the stroke. Given a set of coordinates si, computing the coe\ufb03cients cor- responds to solving the following linear system of equa- tions: \uf8ee \uf8ef\uf8ef\uf8ef\uf8f0 x1 y1 t1 x2 y2 t2 ... ... ... xN yN tN \uf8f9 \uf8fa\uf8fa\uf8fa\uf8fb | {z } Z = \uf8ee \uf8ef\uf8ef\uf8ef\uf8f0 1 s1 s2 1 s3 1 1 s2 s2 2 s3 2 ... ... ... ... 1 sN s2 N s3 N \uf8f9 \uf8fa\uf8fa\uf8fa\uf8fb | {z } V \uf8ee \uf8ef\uf8ef\uf8f0 \u03b10 \u03b20 \u03b30 \u03b11 \u03b21 \u03b31 \u03b12 \u03b22 \u03b32 \u03b13 \u03b23 \u03b33 \uf8f9 \uf8fa\uf8fa\uf8fb | {z } \u2126 (4) which can be solved exactly for N \u22644, and in the least- squares sense otherwise, e.g.",
      "by solving the normalized equations V TZ = V TV \u2126. (5) for the coe\ufb03cients \u2126. We alternate between minimizing the SSE in eq. (3) and \ufb01nding the corresponding points si, until convergence. The coordinates si are updated using a Newton step on x\u2032(si)(xi \u2212x(si)) + y\u2032(si)(yi \u2212y(si)) = 0, (6) which is zero when (xi \u2212x(si), yi \u2212y(si)) is orthogonal to the direction of the curve (x\u2032(si), y\u2032(si)).",
      "Fast Multi-language LSTM-based Online Handwriting Recognition 5 d1 d2 \u03b11 \u03b12 dx dy Fig. 3 Parameterization of each B\u00e9zier curve used to feed the network. Namely: vector between the endpoints (blue), distance between the control points and the endpoints (green dashed lines, 2 values), and the two angles between each control point and the endpoints (green arcs, 2 values). If (a) the curve cannot \ufb01t the points well (SSE error is too large) or if (b) the curve has too sharp bends (arc length longer than 3 times the endpoint distance) we split the curve into two parts. We determine the split point in case (a) by \ufb01nding the triplet of consecutive points with the smallest angle, and in case (b) as the point closest to the maximum local curvature along the entire B\u00e9zier curve. This heuristic is applied recursively until both the curve matching criteria are met. As a \ufb01nal step, to remove spurious breakpoints, con- secutive curves that can be represented by a single curve are stitched back together, resulting in a compact set of B\u00e9zier curves representing the data within the above constraints.",
      "As a \ufb01nal step, to remove spurious breakpoints, con- secutive curves that can be represented by a single curve are stitched back together, resulting in a compact set of B\u00e9zier curves representing the data within the above constraints. For each consecutive pair of curves, we try to \ufb01t a single curve using the combined set of underly- ing points. If the \ufb01t agrees with the above criteria, we replace the two curves by the new one. This is applied repeatedly until no merging happens anymore. Since the B\u00e9zier coe\ufb03cients \u03b1, \u03b2, and \u03b3 may vary signi\ufb01cantly in range, each curve is fed to the network as a 10-dimensional vector (dx, dy, d1, d2, \u03b11, \u03b12, \u03b31, \u03b32, \u03b33, p), with: \u2013 dx, dy: the vector between the endpoints (cp. \ufb01g- ure 3) \u2013 d1, d2: the distance between the control points and the endpoints relative to the distance between the endpoints (cp.",
      "\ufb01g- ure 3) \u2013 d1, d2: the distance between the control points and the endpoints relative to the distance between the endpoints (cp. \ufb01gure 3), \u2013 \u03b11, \u03b12: the angles between control points and end- points in radians (cp. \ufb01gure 3), \u2013 \u03b31, \u03b32 and \u03b33: the time coe\ufb03cients from eq. 1, \u2013 p: a Boolean value indicating whether this is a pen- up or pen-down curve. Due to the normalization of the x, y, and t coordinates, as well as the constraints on the curves themselves, most of the resulting values are in the range [\u22121, 1]. The resulting sequences of 10-dimensional curve rep- resentations are roughly 4\u00d7 shorter than the correspond- ing 5-dimensional raw representation (sec.2.1.1) because each Bezier curve represents multiple points. This leads to faster recognition and thus better latency.",
      "The resulting sequences of 10-dimensional curve rep- resentations are roughly 4\u00d7 shorter than the correspond- ing 5-dimensional raw representation (sec.2.1.1) because each Bezier curve represents multiple points. This leads to faster recognition and thus better latency. In most of the cases, as highlighted through the ex- perimental sections in this paper, the curve represen- tations do not have a big impact on accuracy but con- tribute to faster speed of our models. 2.2 Bidirectional Long-Short-Term-Memory Recurrent Neural Networks LSTMs [19] have become one of the most commonly used RNN cells because they are easy to train and give good results [24]. In all experiments we use bidirectional LSTMs [6, 12], i.e. we process the input sequence for- ward and backward and merge the output states of each layer before feeding them to the next layer. The exact number of layers and nodes is determined empirically for each script. We give an overview of the impact of the number of nodes and layers in section 4.",
      "we process the input sequence for- ward and backward and merge the output states of each layer before feeding them to the next layer. The exact number of layers and nodes is determined empirically for each script. We give an overview of the impact of the number of nodes and layers in section 4. We also list the con\ufb01gurations for several scripts in our production system, as of this writing. 2.3 Softmax Layer The output of the LSTM layers at each timestep is fed into a softmax layer to get a probability distribution over the C possible characters in the script (including spaces, punctuation marks, numbers or other special characters), plus the blank label required by the CTC loss and decoder. 2.4 Decoding The output of the softmax layer is a sequence of T time steps of (C +1) classes that we decode using CTC decoding [12]. The logits from the softmax layer are combined with language-speci\ufb01c prior knowledge (cp. Sec. 2.5). For each of these additional knowledge sources we learn a weight (called \u201cdecoder weight\u201d in the follow- ing) and combine them linearly (cp. Sec. 3).",
      "Sec. 2.5). For each of these additional knowledge sources we learn a weight (called \u201cdecoder weight\u201d in the follow- ing) and combine them linearly (cp. Sec. 3). The learned combination is used as described in [13] to guide the beam search during decoding.6 This combination of di\ufb00erent knowledge sources al- lows us to train one recognition model per script (e.g. Latin script, or Cyrillic script) and then use it to serve multiple languages (see Table 1). 6 We implement this as a BaseBeamScorer (https: //github.com/tensorflow/tensorflow/blob/master/ tensorflow/core/util/ctc/ctc_beam_scorer.h) which is passed to the CTCBeamSearchDecoder implementation in Tensor- Flow [1].",
      "6 Victor Carbune et al. 2.5 Feature Functions: Language Models and Character Classes Similarly to our previous work [25], we de\ufb01ne several scoring functions, which we refer to as feature functions. The goal of these feature functions is to introduce prior knowledge about the underlying language into the sys- tem. The introduction of recurrent neural networks has reduced the need for many of them and we now use only the following three: \u2013 Character Language Models: For each language we support, we build a 7-gram language model over Unicode codepoints from a large web-mined text corpus using Stupid back-o\ufb00[3]. The \ufb01nal \ufb01les are pruned to 10 million 7-grams each. Compared to our previous system [25], we found that language model size has a smaller impact on the recognition accuracy, which is likely due to the capability of recurrent neural networks to capture dependencies between consecutive characters. We therefore use smaller language models over shorter contexts.",
      "Compared to our previous system [25], we found that language model size has a smaller impact on the recognition accuracy, which is likely due to the capability of recurrent neural networks to capture dependencies between consecutive characters. We therefore use smaller language models over shorter contexts. \u2013 Word Language Models: For languages using spaces to separate words, we also use a word-based lan- guage model trained on a similar corpus as the char- acter language models [4,39], using 3-grams pruned to between 1.25 million and 1.5 million entries. \u2013 Character Classes: We add a scoring heuristic which boosts the score of characters from the language\u2019s alphabet. This feature function provides a strong signal for rare characters that may not be recog- nized con\ufb01dently by the LSTM, and which the other language models might not weigh heavily enough to be recognized. This feature function was inspired by our previous system [25]. In Section 4 we provide an experimental evaluation of how much each of these feature functions contributes to the \ufb01nal result for several languages. 3 Training The training of our system happens in two stages, on two di\ufb00erent datasets: 1.",
      "In Section 4 we provide an experimental evaluation of how much each of these feature functions contributes to the \ufb01nal result for several languages. 3 Training The training of our system happens in two stages, on two di\ufb00erent datasets: 1. End-to-end training of the neural network model us- ing the CTC loss using a large training dataset 2. Tuning of the decoder weights using Bayesian opti- mization through Gaussian Processes in Vizier [11], using a much smaller and distinct dataset. Using separate datasets is important because the neu- ral network learns the local appearance as well as an implicit language model from the training data. It will be overcon\ufb01dent on its training data and thus learning the decoder weights on the same dataset could result in weights biased towards the neural network model. 3.1 Connectionist Temporal Classi\ufb01cation Loss As our training data does not contain frame-aligned la- bels, we rely on the CTC loss [12] for training which treats the alignment between inputs and labels as a hidden variable.",
      "3.1 Connectionist Temporal Classi\ufb01cation Loss As our training data does not contain frame-aligned la- bels, we rely on the CTC loss [12] for training which treats the alignment between inputs and labels as a hidden variable. CTC training introduces an additional blank label which is used internally for learning align- ments jointly with character hypotheses, as described in [12]. We train all neural network weights jointly using the standard TensorFlow [1] implementation of CTC train- ing using the Adam Optimizer [27] with a batch size of 8, a learning rate of 10\u22124, and gradient clipping such that the gradient L2-norm is \u22649. Additionally, to im- prove the robustness of our models and prevent over\ufb01t- ting, we train our models using random dropout [18,36] after each LSTM layer with a dropout rate of 0.5. We train until the error rate on the evaluation dataset no longer improves for 5 million steps.",
      "We train until the error rate on the evaluation dataset no longer improves for 5 million steps. 3.2 Bayesian Optimization for Tuning Decoder Weights To optimize the decoder weights, we rely on the Google Vizier service and its default algorithm, speci\ufb01cally batched Gaussian process bandits, and expected improvement as the acquisition function [11]. For each recognizer training we start 7 Vizier stud- ies, each performing 500 individual trials, and then we pick the con\ufb01guration that performed best across all of these trials. We experimentally found that using 7 separate studies with di\ufb00erent random initializations regularly leads to better results than running a single study once. We found that using more than 500 trials per study does not lead to any additional improvement. For each script we train these weights on a subset of the languages for which we have su\ufb03cient data, and transfer the weights to all the other languages. E.g. for the Latin-script languages, we train the decoder weights on English and German, and use the resulting weights for all languages in the \ufb01rst row of Table 1.",
      "E.g. for the Latin-script languages, we train the decoder weights on English and German, and use the resulting weights for all languages in the \ufb01rst row of Table 1. 4 Experimental Evaluation In the following, where possible, we present results for public datasets in a closed data scenario, i.e. training and testing models on the public dataset using a stan- dard protocol. In addition we present evaluation results for public datasets in an open data scenario against our production setup, i.e. in which the model is trained on our own data. Finally, we show experimental results for some of the major languages on our internal datasets. Whenever possible we compare these results to the state of the art and to our previous system [25].",
      "Fast Multi-language LSTM-based Online Handwriting Recognition 7 Table 2 Comparison of character error rates (lower is better) on the IAM-OnDB test set for di\ufb00erent LSTM layers con\ufb01gurations. For each LSTM width and input type, we show the best result in bold. input lstm 64 nodes 128 nodes 256 nodes 1 layer 6.1 5.95 5.56 raw 3 layers 4.03 4.73 4.34 5 layers 4.34 4.20 4.17 1 layer 6.57 6.38 6.98 curves 3 layers 4.16 4.16 4.83 5 layers 4.02 4.22 4.11 Table 3 Error rates on the IAM-OnDB test set in comparison to the state of the art and our previous system [25]. A \"*\" in the \"system\" column indicates the use of an open training set. \"FF\" stands for \"feature functions\" as described in sec. 2.4. system CER[%] WER[%] Frinken et al.",
      "A \"*\" in the \"system\" column indicates the use of an open training set. \"FF\" stands for \"feature functions\" as described in sec. 2.4. system CER[%] WER[%] Frinken et al. BLSTM [7] 12.3 25.0 Graves et al. BLSTM [15] 11.5 20.3 Liwicki et al. LSTM [32] - 18.9 this work (curve, 5x64, no FF) 5.9 18.6 this work (curve, 5x64, FF) 4.0 10.6 our previous BLSTM [25] * 8.8 26.7 combination [32] * - 13.8 our Segment-and-Decode [25] * 4.3 10.4 this work (production system) * 2.5 6.5 4.1 IAM-OnDB The IAM-OnDB dataset [31] is probably the most used evaluation dataset for online handwriting recognition.",
      "It consists of 298 523 characters in 86 272 word instances from a dictionary of 11 059 words written by 221 writ- ers. We use the standard IAM-OnDB dataset separa- tion: one training set, two validations sets and a test set containing 5 363, 1 438, 1 518 and 3 859 written lines, respectively. We tune the decoder weights using the val- idation set with 1 438 items and report error rates on the test set. We perform a more extensive study of the number of layers and nodes per layer for both the raw and curve input formats to determine the optimal size of the bidi- rectional LSTM network (see Figure 4, Table 2). We \ufb01rst run experiments without additional feature func- tions (Figure 4, solid lines), then re-compute the results with tuned weights for language models and character classes (Figure 4, dashed lines). We observe that for both input formats, using 3 or 5 layers outperforms more shallow networks, and using more layers gives hardly any improvement.",
      "We observe that for both input formats, using 3 or 5 layers outperforms more shallow networks, and using more layers gives hardly any improvement. Furthermore, using 64 nodes per layer is su\ufb03cient, as wider networks give only small improvements, if at all. We see no signi\ufb01cant di\ufb00erence in accuracy between the raw and the curve representa- tion. Finally, we show a comparison of our old and new systems with the literature on the IAM-OnDB dataset in Table 3. Our method establishes a new state of the art result when relying on closed data using IAM-OnDB, as well as when relying on our in-house data that we use for our production system, which was not tuned for the IAM-OnDB data and for which none of the IAM-OnDB data was used for training. To better understand where the improvements come from, we discuss the di\ufb00erences between the previous state-of-the-art system (Graves et al. BLSTM [15]) and this work across four dimensions: input pre-processing and feature extraction, neural network architecture, CTC training and decoding, and model training methodol- ogy.",
      "BLSTM [15]) and this work across four dimensions: input pre-processing and feature extraction, neural network architecture, CTC training and decoding, and model training methodol- ogy. Our input pre-processing (Sec 2.1) di\ufb00ers only in mi- nor ways: the x-coordinate used is not \ufb01rst transformed using a high-pass \ufb01lter, we don\u2019t split text-lines using gaps and we don\u2019t remove delayed strokes, nor do we do any skew and slant correction or other pre-processing. The major di\ufb00erence comes from feature extraction. In contrast to the 25 features per point used in [15], we use either 5 features (raw) or 10 features (curves). While the 25 features included both temporal (position in the time series) and spatial features (o\ufb04ine representation), our work uses only the temporal structure. In contrast also to our previous system [25], using a more compact representation (and reducing the number of points for curves) allows a feature representation, including spa- tial structure, to be learned in the \ufb01rst or upper layers of the neural network.",
      "In contrast also to our previous system [25], using a more compact representation (and reducing the number of points for curves) allows a feature representation, including spa- tial structure, to be learned in the \ufb01rst or upper layers of the neural network. The neural network architecture di\ufb00ers both in in- ternal structure of the LSTM cell as well as in the ar- chitecture con\ufb01guration. Our internal structure di\ufb00ers only in that we do not use peephole connections [9]. As opposed to relying on a single bidirectional LSTM layer of width 100, we experiment with a number of con- \ufb01guration variants as detailed in Figure 4. We note that it is particularly important to have more than one layer in order to learn a meaningful representation without feature extraction. We use the CTC forward-backward training algo- rithm as described in [15], and implemented in Tensor- Flow. The training hyperparameters are described in Section 3.1. The CTC decoding algorithm incorporates feature functions similarly to how the dictionary is incorpo- rated in the previous state-of-the-art system.",
      "The training hyperparameters are described in Section 3.1. The CTC decoding algorithm incorporates feature functions similarly to how the dictionary is incorpo- rated in the previous state-of-the-art system. However, we use more feature functions, our language models are trained on a di\ufb00erent corpus, and the combination weights are optimized separately as described in Sec 3.2. 4.2 IBM-UB-1 Another publicly-accessible English-language dataset is the IBM-UB-1 dataset [43]. From the available datasets therein, we use the English query dataset, which con- sists of 63 268 handwritten English words. As this dataset has not been used often in the academic literature, we",
      "8 Victor Carbune et al.  4  6  8  10  20  30  16  32  64  128  256 CER [%] LSTM nodes 1 layer 3 layers 5 layers 7 layers 9 layers  4  6  8  10  20  30  16  32  64  128  256 CER [%] LSTM nodes 1 layer 3 layers 5 layers 7 layers 9 layers Fig. 4 CER of models trained on the IAM-OnDB dataset with di\ufb00erent numbers of LSTM layers and LSTM nodes using raw (left) and curve (right) inputs. Solid lines indicate results without any language models or feature functions in decoding, dashed lines indicate results with the fully-tuned system. Table 4 Error rates on IBM-UB-1 test set in comparison to our previous system [25]. A \"*\" in the \"system\" column indicates the use of an open training set.",
      "Table 4 Error rates on IBM-UB-1 test set in comparison to our previous system [25]. A \"*\" in the \"system\" column indicates the use of an open training set. system CER[%] WER[%] this work (curve, 5x64, no FF) 6.0 25.1 this work (curve, 5x64, FF) 4.1 15.1 Segment-and-Decode from [25] * 6.7 22.2 this work (production system) (sec 5) * 4.1 15.3 propose an evaluation protocol. We split this dataset into 4 parts with non-overlapping writer IDs: 47 108 items for training, 4 690 for decoder weight tuning, 6 134 for validation and 5 336 for testing7. We perform a similar set of experiments as we did for IAM-OnDB to determine the right depth and width of our neural network architecture. The results of these experiments are shown in Figure 5.",
      "We perform a similar set of experiments as we did for IAM-OnDB to determine the right depth and width of our neural network architecture. The results of these experiments are shown in Figure 5. The conclusion for this dataset is similar to the conclusions we drew for the IAM-OnDB: using networks with 5 layers of bidi- rectional LSTMs with 64 cells each is su\ufb03cient for good accuracy. Less deep and less wide networks perform substantially worse, but larger networks only give small improvements. This is true regardless of the input pro- cessing method chosen and again, we do not see a signif- icant di\ufb00erence in accuracy between the raw and curve representation in accuracy. We give some exemplary results and a comparison with our current production system as well as results for our previous system in Table 4. We note that our current system is about 38% and 32% better (relative) in CER and WER, respectively, when compared to the previous segment-and-decode approach.",
      "We note that our current system is about 38% and 32% better (relative) in CER and WER, respectively, when compared to the previous segment-and-decode approach. The lack of im- provement in error rate when evaluating on our produc- tion system is due to the fact that our datasets contain spaces while the same setup trained solely on IBM-UB- 1 does not. 7 Information about the exact experimental protocol is avail- able at https://arxiv.org/src/1902.10525v1/anc 4.3 Additional public datasets We provide an evaluation of our production system trained on our in-house datasets applied to a number of publicly available benchmark datasets from the liter- ature. More detail about our in-house datasets is avail- able from table 9. Note that for all experiments pre- sented in this section we evaluate our current live sys- tem without any tuning speci\ufb01c to the tasks at hand.",
      "More detail about our in-house datasets is avail- able from table 9. Note that for all experiments pre- sented in this section we evaluate our current live sys- tem without any tuning speci\ufb01c to the tasks at hand. 4.3.1 Chinese Isolated Characters (ICDAR 2013 competition) The ICDAR-2013 Competition for Online Handwrit- ing Chinese Character Recognition [50] introduced a dataset for classifying the most common Chinese char- acters. We report the error rates in comparison to pub- lished results from the competition and more recent work done by others in Table 5. We evaluate our live production system on this dataset. Our system was not tuned to the task at hand and was trained as a multi-character recognizer, thus it is not even aware that each sample only contains a single character. Further, our system supports 12 363 di\ufb00er- ent characters while the competition data only contains 3 755 characters. Note that our system did not have ac- cess to the training data for this task at all.",
      "Further, our system supports 12 363 di\ufb00er- ent characters while the competition data only contains 3 755 characters. Note that our system did not have ac- cess to the training data for this task at all. Whenever our system returns more than one char- acter for a sample, we count this as an error (this hap- pened twice on the entire test set of 224 590 samples). Despite supporting almost four times as many charac- ters than needed for the CASIA data and not having been tuned to the task, the accuracy of our system is still competitive with systems that were tuned for this data speci\ufb01cally.",
      "Fast Multi-language LSTM-based Online Handwriting Recognition 9  4  6  8  10  20  30  16  32  64  128  256 CER [%] LSTM nodes 1 layer 3 layers 5 layers 7 layers 9 layers  4  6  8  10  20  30  16  32  64  128  256 CER [%] LSTM nodes 1 layer 3 layers 5 layers 7 layers 9 layers Fig. 5 CER of models trained on the IBM-UB-1 dataset with di\ufb00erent numbers of LSTM layers and LSTM nodes using raw (left) and curve (right) inputs. Solid lines indicate results without any language models or feature functions in decoding, dashed lines indicate results with the fully-tuned system. Table 5 Error rates on ICDAR-2013 Competition Database of Online Handwritten Chinese Character Recognition. Our system was trained with an open training set, including a mix of charac- ters, words, and phrases.",
      "Table 5 Error rates on ICDAR-2013 Competition Database of Online Handwritten Chinese Character Recognition. Our system was trained with an open training set, including a mix of charac- ters, words, and phrases. system ER[%] Human Performance [50] 4.8 Traditional Benchmark [30] 4.7 ICDAR-2011 Winner [29] 4.2 this work (production system) sec. 5 3.2 ICDAR-2013 Winner: UWarwick [50] 2.6 RNN: NET4 [52] 2.2 100LSTM-512LSTM-512FC-3755FC [49] 2.2 RNN: Ensemble-NET123456 [52] 1.9 Table 6 Results on the VNONDB-Word dataset. public test set secret test set system CER[%] WER[%] CER[%] WER[%] this work (sec.",
      "public test set secret test set system CER[%] WER[%] CER[%] WER[%] this work (sec. 5) 6.1 13.2 9.8 20.5 IVTOVTask1 2.9 6.5 7.3 15.3 MyScriptTask1 2.9 6.5 6.0 12.7 4.3.2 Vietnamese Online Handwriting Recognition (ICFHR 2018 competition) In the ICFHR2018 Competition on Vietnamese Online Handwritten Text Recognition using VNOnDB [34], our production system was evaluated against other systems. The system used in the competition is the one reported and described in this paper. Due to licensing restric- tions we were unable to do any experiments on the com- petition training data, or speci\ufb01c tuning for the com- petition, which was not the case for the other systems mentioned here. We participated in the two tasks that best suited the purpose of our system, speci\ufb01cally the \"Word\" (ref. table 6) and the \"Text line\" (ref.",
      "We participated in the two tasks that best suited the purpose of our system, speci\ufb01cally the \"Word\" (ref. table 6) and the \"Text line\" (ref. table 7) recognition levels. Even though we can technically process para- graph level inputs, our system was not built with this goal in mind. In contrast to us, the other teams used the training and validation sets to tune their systems: Table 7 Results on the VNONDB-Line dataset. public test set secret test set system CER[%] WER[%] CER[%] WER[%] this work (sec. 5) 6.9 19.0 10.3 27.0 IVTOVTask2 3.2 14.1 5.6 21.0 MyScriptTask2_1 1.0 2.0 1.0 3.4 MyScriptTask2_2 1.6 4.0 1.7 5.1 \u2013 The IVTOV team\u2019s system is very similar to our system. It makes use of bidirectional LSTM lay- ers trained end-to-end with the CTC loss.",
      "It makes use of bidirectional LSTM lay- ers trained end-to-end with the CTC loss. The in- puts used are delta x and y coordinates, together with pen-up strokes (boolean feature quantifying whether a stroke has ended or not). They report using a two-layer network of 100 cells each and addi- tional preprocessing for better handling the dataset. \u2013 The MyScript team submitted two systems. The \ufb01rst system has an explicit segmentation compo- nent along with a feed-forward network for recog- nizing character hypotheses, similar in formulation to our previous system [25]. In addition, they also make use of a bidirectional LSTM system trained end-to-end with the CTC loss. They do not provide additional details on which system is which. We note that the modeling stacks of the systems out- performing ours in this competition are not fundamen- tally di\ufb00erent (to the best of our knowledge, accord- ing to released descriptions). We therefore believe that our system might perform comparably if trained on the competition training dataset as well.",
      "We therefore believe that our system might perform comparably if trained on the competition training dataset as well. On our internal testset of Vietnamese data, our new system obtains a CER of 3.3% which is 54% relative better than the old Segment-and-Decode system which had a CER of 7.2% (see also Table 7).",
      "10 Victor Carbune et al. 4.4 Tuning neural network parameters on our internal data Our in-house datasets consist of various types of train- ing data, the amount of which varies by script. Sources of training data include data collected through prompt- ing, commercially available data, arti\ufb01cially in\ufb02ated data, and labeled/self-labeled anonymized recognition requests (see [25] for a more detailed description). This leads to more heterogeneous datasets than academic datasets such as IBM-UB-1 or IAM-OnDB which were collected under standardized conditions. The number of training samples varies from tens of thousands to several million per script, depending on the complexity and usage. We provide more information about the size of our internal training and tests datasets in table 9. The best con\ufb01guration for our system was identi\ufb01ed by running multiple experiments over a range of layer depths and widths on our internal datasets. For the Latin script experiments shown in Figure 6, the training set we used was a mixture of data from all the Latin- script languages we support and evaluation is done on an English validation dataset, also used for the English evaluation in Table 9.",
      "For the Latin script experiments shown in Figure 6, the training set we used was a mixture of data from all the Latin- script languages we support and evaluation is done on an English validation dataset, also used for the English evaluation in Table 9. Similarly to experiments depicted in Figures 4 and 5, increasing the depth and width of the network archi- tecture brings diminishing returns fairly quickly. How- ever, over\ufb01tting is less pronounced probably because our datasets are substantially larger than the publicly available datasets. For the experiments with our production datasets we are using the B\u00e9zier curve inputs which perform slightly better in terms of accuracy than the raw in- put encoding but are much faster to train and evaluate because of the shorter sequence lengths. 5 System Performance and Discussion The setup described throughout this paper that ob- tained the best results relies on input processing with B\u00e9zier spline interpolation (Sec. 2.1.2), followed by 4\u20135 layers of varying width bidirectional LSTMs, followed by a \ufb01nal softmax layer. For each script, we experimen- tally determined the best con\ufb01guration through multi- ple training runs.",
      "2.1.2), followed by 4\u20135 layers of varying width bidirectional LSTMs, followed by a \ufb01nal softmax layer. For each script, we experimen- tally determined the best con\ufb01guration through multi- ple training runs. We performed an ablation study with the best con- \ufb01gurations for each of the six most important scripts8 by number of users and compare the results with our previous work [25] (Table 9). The largest relative im- provement comes from the overall network architecture stack, followed by the use of the character language model and the other feature functions. 8 For Latin script we report results for 3 languages. Table 8 CER comparison when training and evaluating IAM- OnDB, IBM-UB-1 and our Latin training/eval set. We want to highlight the fundamental di\ufb00erences between the di\ufb00erent datasets.",
      "Table 8 CER comparison when training and evaluating IAM- OnDB, IBM-UB-1 and our Latin training/eval set. We want to highlight the fundamental di\ufb00erences between the di\ufb00erent datasets. train/test IAM-OnDB IBM-UB-1 own dataset IAM-OnDB 3.8 17.7 31.2 IBM-UB-1 35.1 4.1 32.9 own dataset 3.3 4.8 8.7 In addition, we show the relative improvement in error rates on the languages for which we have evalua- tion datasets of more than 2 000 items (Figure 7). The new architecture performs between 20%\u201340% (relative) better over almost all languages. 5.1 Di\ufb00erences Between IAM-OnDB, IBM-UB-1 and our internal datasets To understand how the di\ufb00erent datasets relate to each other, we performed a set of experiments and evalua- tions with the goal of better characterizing the di\ufb00er- ences between the datasets.",
      "We trained a recognizer on each of the three train- ing sets separately, then evaluated each system on all three test sets (Table 8). The neural network architec- ture is the same as the one we determined earlier (5 layers bidirectional LSTMs of 64 cells each) with the same feature functions, with weights tuned on the cor- responding tuning dataset. The inputs are processed using B\u00e9zier curves. To better understand the source of discrepancy when training on IAM-OnDB and evaluating on IBM-UB-1, we note the di\ufb00erent characteristics of the datasets: \u2013 IBM-UB-1 has predominantly cursive writing, while IAM-OnDB has mostly printed writing \u2013 IBM-UB-1 contains single words, while IAM-OnDB has lines of space-separated words This results in models trained on the IBM-UB-1 dataset not being able to predict spaces as they are not present in the dataset\u2019s alphabet. In addition, the printed writing style of IAM-OnDB makes recognition harder when evaluating cursive writing from IBM-UB- 1.",
      "In addition, the printed writing style of IAM-OnDB makes recognition harder when evaluating cursive writing from IBM-UB- 1. It is likely that the lack of structure through words- only data makes recognizing IAM-OnDB on a system trained on IBM-UB-1 harder than vice-versa. Systems trained on IBM-UB-1 or IAM-OnDB alone perform signi\ufb01cantly worse on our internal datasets, as our data distribution covers a wide range of use-cases not necessarily relevant to, or present, in the two aca- demic datasets: sloppy handwriting, overlapping char- acters for handling writing on small input surfaces, non- uniform sampling rates, and partially rotated inputs. The network trained on the internal dataset per- forms well on all three datasets. It performs better on",
      "Fast Multi-language LSTM-based Online Handwriting Recognition 11  6  8  10  20  30  16  32  64  128  196 CER [%] LSTM nodes 1 layer 3 layers 5 layers 7 layers 9 layers  6  8  10  20  30  16  32  64  128  196 CER [%] LSTM nodes 1 layer 3 layers 5 layers 7 layers 9 layers Fig. 6 CER of models trained on our internal datasets evaluated on our English-language validation set with di\ufb00erent numbers of LSTM layers and LSTM nodes using raw (left) and curve (right) inputs. Solid lines indicate results without any language models or feature functions in decoding, dashed lines indicate results with the fully-tuned system. IAM-OnDB than the system trained only thereon, but worse for IBM-UB-1. We believe that using only cur- sive words when training allows the network to bet- ter learn the sample characteristics, than when learning about space separation and other structure properties not present in IBM-UB-1.",
      "We believe that using only cur- sive words when training allows the network to bet- ter learn the sample characteristics, than when learning about space separation and other structure properties not present in IBM-UB-1. 6 Conclusion We describe the online handwriting recognition sys- tem that we currently use at Google for 102 languages in 26 scripts. The system is based on an end-to-end trained neural network and replaces our old Segment- and-Decode system. Recognition accuracy of the new system improves by 20% to 40% relative depending on the language while using smaller and faster models. We encode the touch inputs using a B\u00e9zier curve represen- tation which performs at least as well as raw touch in- puts but which also allows for a faster recognition be- cause the input sequence representation is shorter. We further compare the performance of our system to the state of the art on publicly available datasets such as IAM-OnDB, IBM-UB-1, and CASIA and improve over the previous best published result on IAM-OnDB.",
      "We further compare the performance of our system to the state of the art on publicly available datasets such as IAM-OnDB, IBM-UB-1, and CASIA and improve over the previous best published result on IAM-OnDB. Acknowledgements We would like to thank the following contributors for fruitful discussions, ideas, and support: Ashok Popat, Yasuhisa Fujii, Dmitriy Genzel, Jake Walker, David Ry- bach, Daan van Esch, and Eugene Brevdo. We thank Google\u2019s OCR team for the numerous collaborations throughout the years that have made this work easier, as well as the speech recognition and machine transla- tion teams at Google for tools and support for some of the components we use in this paper. References 1.",
      "We thank Google\u2019s OCR team for the numerous collaborations throughout the years that have made this work easier, as well as the speech recognition and machine transla- tion teams at Google for tools and support for some of the components we use in this paper. References 1. Abadi, M., Agarwal, A., Barham, P., Brevdo, E., Chen, Z., Citro, C., Corrado, G.S., Davis, A., Dean, J., Devin, M., Ghe- mawat, S., Goodfellow, I., Harp, A., Irving, G., Isard, M., Jia, Y., Jozefowicz, R., Kaiser, L., Kudlur, M., Levenberg, J., Man\u00e9, D., Monga, R., Moore, S., Murray, D., Olah, C., Schuster, M., Shlens, J., Steiner, B., Sutskever, I., Talwar, K., Tucker, P., Vanhoucke, V., Vasudevan, V., Vi\u00e9gas, F., Vinyals, O., Warden, P., Wattenberg, M., Wicke, M., Yu, Y., Zheng, X.: TensorFlow: Large-scale machine learning on het- erogeneous systems (2015).",
      "URL https://www.tensorflow. org/. Software available from tensor\ufb02ow.org 2. Bengio, Y., LeCun, Y., Nohl, C., Burges, C.: Lerec: A NN/HMM hybrid for on-line handwriting recognition. Neu- ral Computation 7(6), 1289\u20131303 (1995) 3. Brants, T., Popat, A.C., Xu, P., Och, F.J., Dean, J.: Large language models in machine translation. In: EMNLP- CoNLL, pp. 858\u2013867 (2007) 4. Chua, M., van Esch, D., Coccaro, N., Cho, E., Bhandari, S., Jia, L.: Text normalization infrastructure that scales to hundreds of language varieties. In: Proceedings of the 11th edition of the Language Resources and Evaluation Confer- ence (2018) 5. Franzini, M., Lee, K.F., Waibel, A.: Connectionist Viterbi training: a new hybrid method for continuous speech recog- nition.",
      "Franzini, M., Lee, K.F., Waibel, A.: Connectionist Viterbi training: a new hybrid method for continuous speech recog- nition. In: Acoustics, Speech, and Signal Processing, 1990. ICASSP-90., 1990 International Conference on, pp. 425\u2013428. IEEE (1990) 6. Frinken, V., Bhattacharya, N., Uchida, S., Pal, U.: Improved blstm neural networks for recognition of on-line bangla com- plex words. In: S+SSPR (2014) 7. Frinken, V., Uchida, S.: Deep BLSTM neural networks for unconstrained continuous handwritten text recognition. In: ICDAR (2015) 8. Fujii, Y., Driesen, K., Baccash, J., Hurst, A., Popat, A.C.: Sequence-to-label script identi\ufb01cation for multilingual OCR. In: ICDAR (2017) 9.",
      "Fujii, Y., Driesen, K., Baccash, J., Hurst, A., Popat, A.C.: Sequence-to-label script identi\ufb01cation for multilingual OCR. In: ICDAR (2017) 9. Gers, F.A., Schmidhuber, E.: Lstm recurrent networks learn simple context-free and context-sensitive languages. IEEE Transactions on Neural Networks 12(6), 1333\u20131340 (2001) 10. Ghosh, S., Joshi, A.: Text entry in indian languages on mo- bile: User perspectives. In: India HCI (2014) 11. Golovin, D., Solnik, B., Moitra, S., Kochanski, G., Karro, J.E., Sculley, D. (eds.): Google Vizier: A Service for Black- Box Optimization (2017) 12. Graves, A., Fern\u00e1ndez, S., Gomez, F.J., Schmidhuber, J.: Connectionist temporal classi\ufb01cation: labelling unsegmented sequence data with recurrent neural networks.",
      "Graves, A., Fern\u00e1ndez, S., Gomez, F.J., Schmidhuber, J.: Connectionist temporal classi\ufb01cation: labelling unsegmented sequence data with recurrent neural networks. In: ICML (2006)",
      "12 Victor Carbune et al. Table 9 Character error rates on the validation data using successively more of the system components described above for English (en), Spanish (es), German (de), Arabic (ar), Korean (ko), Thai (th), Hindi (hi), and Chinese (zh) along with the respective number of items and characters in the test and training datasets. Average latencies for all languages and models were computed on an Intel Xeon E5-2690 CPU running at 2.6 GHz.",
      "Average latencies for all languages and models were computed on an Intel Xeon E5-2690 CPU running at 2.6 GHz. Language en es de ar ko th hi zh Internal test data (per language) Items 32 645 7 136 14 408 11 617 22 951 23 608 9 030 197 547 Characters 162 367 40 302 83 231 84 017 55 654 109 793 36 726 312 478 Internal training data (per script) Items 3 293 421 570 375 3 495 877 207 833 1 004 814 5 969 179 Characters 15 850 724 4 597 255 4 770 486 989 520 5 575 552 7 548 434 Unique supported characters 295 337 3524 195 197 12 726 System CER [%] Segment-and-Decode [25] 7.5 7.2 6.0 14.8 13.8 4.1 15.7 3.",
      "5 7.2 6.0 14.8 13.8 4.1 15.7 3.76 BLSTM (comparison) [25] 10.2 12.4 9.5 18.2 44.2 3.9 15.4 \u2014 Model architecture (this work) 5\u00d7224 5\u00d7160 5\u00d7160 5\u00d7128 5\u00d7192 4\u00d7192 (2) BLSTM-CTC Baseline Curves 8.00 6.38 7.12 12.29 6.87 2.41 7.65 1.54 (3) + n-gram LM 6.54 4.64 5.43 8.10 6.90 1.82 7.00 1.38 (4) + character classes 6.60 4.59 5.36 7.93 6.79 1.78 7.32 1.39 (5) + word LM 6.48 4.56 5.40 7.87 \u2014 \u2014 7.42 \u2014- Avg.",
      "60 4.59 5.36 7.93 6.79 1.78 7.32 1.39 (5) + word LM 6.48 4.56 5.40 7.87 \u2014 \u2014 7.42 \u2014- Avg. latency per item [ms] Segment-and-Decode [25] 315 359 372 221 389 165 139 208 This work 23 25 26 14 20 13 19 30 Number of parameters (per script) Segment-and-Decode [25] 5 281 061 5 342 561 8 381 686 6 318 361 9 721 361 \u2014 This work 5 386 170 2 776 937 3 746 999 1 769 668 3 927 736 7 729 994 13. Graves, A., Jaitly, N.: Towards end-to-end speech recognition with recurrent neural networks. In: ICML (2014) 14.",
      "Graves, A., Jaitly, N.: Towards end-to-end speech recognition with recurrent neural networks. In: ICML (2014) 14. Graves, A., Liwicki, M., Bunke, H., Schmidhuber, J., Fern\u00e1n- dez, S.: Unconstrained on-line handwriting recognition with recurrent neural networks. In: Advances in neural informa- tion processing systems, pp. 577\u2013584 (2008) 15. Graves, A., Liwicki, M., Fernandez, S., Bertolami, R., Bunke, H., Schmidhuber, J.: A novel connectionist system for un- constrained handwriting recognition. IEEE Trans. Pattern Analysis & Machine Intelligence 31(5), 855\u2013868 (2009) 16. Graves, A., Schmidhuber, J.: O\ufb04ine handwriting recognition with multidimensional recurrent neural networks. In: Ad- vances in neural information processing systems, pp. 545\u2013552 (2009) 17.",
      "Graves, A., Schmidhuber, J.: O\ufb04ine handwriting recognition with multidimensional recurrent neural networks. In: Ad- vances in neural information processing systems, pp. 545\u2013552 (2009) 17. Hinton, G., Deng, L., Yu, D., Dahl, G.E., Mohamed, A.r., Jaitly, N., Senior, A., Vanhoucke, V., Nguyen, P., Sainath, T.N., et al.: Deep neural networks for acoustic modeling in speech recognition: The shared views of four research groups. IEEE Signal processing magazine 29(6), 82\u201397 (2012) 18. Hinton, G.E., Srivastava, N., Krizhevsky, A., Sutskever, I., Salakhutdinov, R.R.: Improving neural networks by pre- venting co-adaptation of feature detectors. arXiv preprint arXiv:1207.0580 (2012) 19. Hochreiter, S., Schmidhuber, J.: Long short-term memory.",
      ": Improving neural networks by pre- venting co-adaptation of feature detectors. arXiv preprint arXiv:1207.0580 (2012) 19. Hochreiter, S., Schmidhuber, J.: Long short-term memory. Neural Computation 9(8), 1735\u20131780 (1997) 20. Hu, J., Brown, M.K., Turin, W.: HMM based online hand- writing recognition. IEEE Transactions on pattern analysis and machine intelligence 18(10), 1039\u20131045 (1996) 21. Huang, B.Q., Zhang, Y., Kechadi, M.T.: Preprocessing tech- niques for online handwriting recognition. In: Intelligent Sys- tems Design and Applications, 2007. ISDA 2007. Seventh In- ternational Conference on, pp. 793\u2013800. IEEE (2007) 22. Jaeger, S., Manke, S., Reichert, J., Waibel, A.: Online hand- writing recognition: the NPen++ recognizer.",
      "Seventh In- ternational Conference on, pp. 793\u2013800. IEEE (2007) 22. Jaeger, S., Manke, S., Reichert, J., Waibel, A.: Online hand- writing recognition: the NPen++ recognizer. International Journal on Document Analysis and Recognition 3(3), 169\u2013 180 (2001) 23. J\u00e4ger, S., Liu, C., Nakagawa, M.: The state of the art in Japanese online handwriting recognition compared to tech- niques in western handwriting recognition. International Journal on Document Analysis and Recognition 6(2), 75\u201388 (2003) 24. Jozefowicz, R., Zaremba, W., Sutskever, I.: An empirical exploration of recurrent network architectures. In: Inter- national Conference on Machine Learning, pp. 2342\u20132350 (2015) 25. Keysers, D., Deselaers, T., Rowley, H., Wang, L.L., Carbune, V.: Multi-language online handwriting recognition. IEEE Trans.",
      "In: Inter- national Conference on Machine Learning, pp. 2342\u20132350 (2015) 25. Keysers, D., Deselaers, T., Rowley, H., Wang, L.L., Carbune, V.: Multi-language online handwriting recognition. IEEE Trans. Pattern Analysis & Machine Intelligence 39(6), 1180\u2013 1194 (2017) 26. Kim, J.H., Sin, B.: Online handwriting recognition. In: Hand- book of Document Image Processing & Recognition, pp. 887\u2013 915. Springer-Verlag London (2014) 27. Kingma, D.P., Ba, J.: Adam: A method for stochastic opti- mization. ICLR (2014) 28. LeCun, Y., Bottou, L., andPatrick Ha\ufb00ner, Y.B.: Gradient- based learning applied to document recognition. In: Proceed- ings of the IEEE (1998) 29. Liu, C., Yin, F., Wang, Q., Wang, D.: ICDAR 2011 Chinese handwriting recognition competition.",
      ": Gradient- based learning applied to document recognition. In: Proceed- ings of the IEEE (1998) 29. Liu, C., Yin, F., Wang, Q., Wang, D.: ICDAR 2011 Chinese handwriting recognition competition. In: ICDAR (2011) 30. Liu, C.L., Yin, F., Wang, D.H., Wang, Q.F.: Online and of- \ufb02ine handwritten Chinese character recognition: benchmark- ing on new databases. Pattern Recognition 46(1), 155\u2013162 (2013) 31. Liwicki, M., Bunke, H.: IAM-OnDB-an on-line English sen- tence database acquired from handwritten text on a white- board. In: ICDAR, pp. 956\u2013961 (2005) 32. Liwicki, M., Bunke, H., Pittman, J.A., Knerr, S.: Combining diverse systems for handwritten text line recognition. Mach. Vis. Appl. 22(1), 39\u201351 (2011) 33.",
      "Liwicki, M., Bunke, H., Pittman, J.A., Knerr, S.: Combining diverse systems for handwritten text line recognition. Mach. Vis. Appl. 22(1), 39\u201351 (2011) 33. Mikolov, T., Sutskever, I., Chen, K., Corrado, G.S., Dean, J.: Distributed representations of words and phrases and their compositionality. In: Advances in neural information pro- cessing systems, pp. 3111\u20133119 (2013)",
      "Fast Multi-language LSTM-based Online Handwriting Recognition 13  0  2  4  6  8  10  12  14  16  0  2  4  6  8  10  12  14  16 20% improvement 40% improvement LSTM CER [%] SD CER [%] af ar bg bn ca cs da de el en es fa \ufb01 fr gl gu hi hu hy id it iw ja ka km kn ko lo lt ml mr ms my ne nl or pa pl pt ro ru si sk sl sv ta te th tr uk ur vi zh Fig. 7 A comparison of the CERs for the LSTM and SD (Segment-and-Decode) system for all languages on our internal test sets with more than 2000 items. The scatter plot shows the ISO language code at a position corresponding to the CER for the SD system (x-axis) and LSTM system (y-axis). Points below the diagonal are improvements of LSTM over SD. The plot also shows the lines of 20% and 40% relative improvement. 34.",
      "Points below the diagonal are improvements of LSTM over SD. The plot also shows the lines of 20% and 40% relative improvement. 34. Nguyen, H.T., Nguyen, C.T., Nakagawa, M.: ICFHR 2018 \u2013 competition on Vietnamese online handwritten text recog- nition using HANDS-VNOnDB (VOHTR2018). In: ICFHR (2018) 35. Nuntawisuttiwong, T., Dejdumrong, N.: Approximating on- line handwritten image by b\u00e9zier curve. In: CGIV (2012) 36. Pham, V., Bluche, T., Kermorvant, C., Louradour, J.: Dropout improves recurrent neural networks for handwrit- ing recognition. In: Frontiers in Handwriting Recognition (ICFHR), 2014 14th International Conference on, pp. 285\u2013 290. IEEE (2014) 37. Pittman, J.A.: Handwriting recognition: Tablet PC text in- put.",
      "In: Frontiers in Handwriting Recognition (ICFHR), 2014 14th International Conference on, pp. 285\u2013 290. IEEE (2014) 37. Pittman, J.A.: Handwriting recognition: Tablet PC text in- put. IEEE Computer 40(9), 49\u201354 (2007) 38. Plamondon, R., Srihari, S.N.: Online and o\ufb00-line handwriting recognition: a comprehensive survey. IEEE Transactions on pattern analysis and machine intelligence 22(1), 63\u201384 (2000) 39. Prasad, M., Breiner, T., van Esch, D.: Mining training data for language modeling across the world\u2019s languages. In: Pro- ceedings of the 6th International Workshop on Spoken Lan- guage Technologies for Under-resourced Languages (SLTU 2018) (2018) 40.",
      "In: Pro- ceedings of the 6th International Workshop on Spoken Lan- guage Technologies for Under-resourced Languages (SLTU 2018) (2018) 40. Sainath, T.N., Kingsbury, B., Saon, G., Soltau, H., Mo- hamed, A.r., Dahl, G., Ramabhadran, B.: Deep convolutional neural networks for large-scale speech tasks. Neural Networks 64, 39\u201348 (2015) 41. Sainath, T.N., Vinyals, O., Senior, A., Sak, H.: Convolu- tional, long short-term memory, fully connected deep neural networks. In: ICASSP (2015) 42. Schuster, M., Paliwal, K.K.: Bidirectional recurrent neural networks. IEEE Transactions on Signal Processing 45(11), 2673\u20132681 (1997) 43. Shivram, A., Ramaiah, C., Setlur, S., Govindaraju, V.: IBM_UB_1: A dual mode unconstrained English handwrit- ing dataset.",
      "Shivram, A., Ramaiah, C., Setlur, S., Govindaraju, V.: IBM_UB_1: A dual mode unconstrained English handwrit- ing dataset. In: ICDAR (2013) 44. Simonyan, K., Zisserman, A.: Very deep convolutional net- works for large-scale image recognition. arXiv preprint arXiv:1409.1556 (2014) 45. Szegedy, C., Vanhoucke, V., Io\ufb00e, S., Shlens, J., Wojna, Z.: Rethinking the inception architecture for computer vision. In: Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 2818\u20132826 (2016) 46. Waibel, A., Hanazawa, T., Hinton, G., Shikano, K., Lang, K.J.: Phoneme recognition using time-delay neural networks. IEEE Transactions on Acoustics, Speech, and Signal Process- ing (1989) 47.",
      "Waibel, A., Hanazawa, T., Hinton, G., Shikano, K., Lang, K.J.: Phoneme recognition using time-delay neural networks. IEEE Transactions on Acoustics, Speech, and Signal Process- ing (1989) 47. Wang, T., Wu, D.J., Coates, A., Ng, A.Y.: End-to-end text recognition with convolutional neural networks. ICPR (2012) 48. Yaeger, L., Webb, B., Lyon, R.: Combining neural networks and context-driven search for on-line, printed handwriting recognition in the Newton. AAAI AI Magazine (1998) 49. Yang, Y., Liang, K., Xiao, X., Xie, Z., Jin, L., Sun, J., Zhou, W.: Accelerating and compressing LSTM based model for on- line handwritten Chinese character recognition. In: ICFHR (2018) 50. Yin, F., Wang, Q.F., Zhang, X.Y., Liu, C.L.: Icdar 2013 Chinese handwriting recognition competition. In: Document",
      "14 Victor Carbune et al. Analysis and Recognition (ICDAR), 2013 12th International Conference on, pp. 1464\u20131470. IEEE (2013) 51. Zhang, J., Du, J., Dai, L.: A GRU-based encoder-decoder ap- proach with attention for online handwritten mathematical expression recognition. ArXiV (2017) 52. Zhang, X., Yin, F., Zhang, Y., Liu, C., Bengio, Y.: Draw- ing and recognizing Chinese characters with recurrent neural network. ArXiV (2016)"
    ],
    "queries":"/future/u/okhattab/data/MSMARCO/queries.train.tsv",
    "index_name":"PaperTab-question-1902.10525.pdf",
    "overwrite":false,
    "root":".ragatouille/",
    "experiment":"colbert",
    "index_root":null,
    "name":"2025-05/17/10.22.50",
    "rank":0,
    "nranks":1,
    "amp":true,
    "gpus":1,
    "avoid_fork_if_possible":false
  },
  "num_chunks":1,
  "num_partitions":1024,
  "num_embeddings":14678,
  "avg_doclen":170.6744186047,
  "RAGatouille":{
    "index_config":{
      "index_type":"PLAID",
      "index_name":"PaperTab-question-1902.10525.pdf"
    }
  }
}