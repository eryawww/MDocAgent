{
    "config": {
        "query_token_id": "[unused0]",
        "doc_token_id": "[unused1]",
        "query_token": "[Q]",
        "doc_token": "[D]",
        "ncells": null,
        "centroid_score_threshold": null,
        "ndocs": null,
        "load_index_with_mmap": false,
        "index_path": null,
        "index_bsize": 32,
        "nbits": 4,
        "kmeans_niters": 20,
        "resume": false,
        "pool_factor": 1,
        "clustering_mode": "hierarchical",
        "protected_tokens": 0,
        "similarity": "cosine",
        "bsize": 64,
        "accumsteps": 1,
        "lr": 1e-5,
        "maxsteps": 400000,
        "save_every": null,
        "warmup": 20000,
        "warmup_bert": null,
        "relu": false,
        "nway": 64,
        "use_ib_negatives": true,
        "reranker": false,
        "distillation_alpha": 1.0,
        "ignore_scores": false,
        "model_name": null,
        "query_maxlen": 32,
        "attend_to_mask_tokens": false,
        "interaction": "colbert",
        "dim": 128,
        "doc_maxlen": 256,
        "mask_punctuation": true,
        "checkpoint": "colbert-ir\/colbertv2.0",
        "triples": "\/future\/u\/okhattab\/root\/unit\/experiments\/2021.10\/downstream.distillation.round2.2_score\/round2.nway6.cosine.ib\/examples.64.json",
        "collection": [
            "HAS-QA: Hierarchical Answer Spans Model for Open-domain Question Answering Liang Pang\u2020, Yanyan Lan\u2020\u2217, Jiafeng Guo\u2020, Jun Xu\u2020, Lixin Su\u2020 and Xueqi Cheng\u2020 \u2020CAS Key Laboratory of Network Data Science and Technology, Institute of Computing Technology, Chinese Academy of Sciences, Beijing, China \u2020University of Chinese Academy of Sciences, Beijing, China \u2217Department of Statistics, University of California, Berkeley {pangliang,lanyanyan,guojiafeng,sulixin,cxq}@ict.ac.cn, junxu@ruc.edu.cn Abstract This paper is concerned with open-domain question answer- ing (i.e., OpenQA). Recently, some works have viewed this problem as a reading comprehension (RC) task, and directly applied successful RC models to it. However, the perform- ances of such models are not so good as that in the RC task.",
            "Recently, some works have viewed this problem as a reading comprehension (RC) task, and directly applied successful RC models to it. However, the perform- ances of such models are not so good as that in the RC task. In our opinion, the perspective of RC ignores three characterist- ics in OpenQA task: 1) many paragraphs without the answer span are included in the data collection; 2) multiple answer spans may exist within one given paragraph; 3) the end pos- ition of an answer span is dependent with the start position. In this paper, we \ufb01rst propose a new probabilistic formula- tion of OpenQA, based on a three-level hierarchical structure, i.e., the question level, the paragraph level and the answer span level. Then a Hierarchical Answer Spans Model (HAS- QA) is designed to capture each probability. HAS-QA has the ability to tackle the above three problems, and experiments on public OpenQA datasets show that it signi\ufb01cantly outper- forms traditional RC baselines and recent OpenQA baselines.",
            "HAS-QA has the ability to tackle the above three problems, and experiments on public OpenQA datasets show that it signi\ufb01cantly outper- forms traditional RC baselines and recent OpenQA baselines. 1 Introduction Open-domain question answering (OpenQA) aims to seek answers for a broad range of questions from a large know- ledge sources, e.g., structured knowledge bases (Berant et al. 2013; Mou et al. 2017) and unstructured documents from search engine (Ferrucci et al. 2010). In this paper we fo- cus on the OpenQA task with the unstructured knowledge sources retrieved by search engine. Inspired by the reading comprehension (RC) task \ufb02our- ishing in the area of natural language processing (Wang and Jiang 2016; Seo et al. 2016; Xiong, Zhong, and Socher 2016), some recent works have viewed OpenQA as an RC task, and directly applied the existing RC models to it (Chen et al. 2017; Joshi et al. 2017; Wang and Jiang 2016; Clark and Gardner 2018).",
            "2017; Joshi et al. 2017; Wang and Jiang 2016; Clark and Gardner 2018). However, these RC models do not well \ufb01t for the OpenQA task. Firstly, they directly omit the paragraphs without answer string1. RC task assumes that the given paragraph contains the answer string (Figure 1 top), however, it is not valid Copyright c\u20dd2019, Association for the Advancement of Arti\ufb01cial Intelligence (www.aaai.org). All rights reserved. 1The answer string is a piece of text that can answer the ques- tion. If the answer string is obtained in a paragraph as a consecutive text, we call it the answer span. Reading Comprehension Open-domain QuestionAnswering Question: What does a camel store in its hump? Paragraph1(multiple-answer-spans): The humps are reservoirs of fatty tissue: concentrating body fat in their humps minimizes the insulating effect fat would have if distributed over the rest of their bodies, helping camels survive in hot climates.",
            "Paragraph1(multiple-answer-spans): The humps are reservoirs of fatty tissue: concentrating body fat in their humps minimizes the insulating effect fat would have if distributed over the rest of their bodies, helping camels survive in hot climates. Paragraph2(no-answer-span): Camels with one hump are called Arabian camels, or Dromedaries, and come from North Africa. Camels with two humps are from Asia, and are called Bactrian camels. Paragraph: At standard temperature and pressure, two atoms of the element bind to form dioxygen, a colorless and odorless diatomic gas with the formula O2. Question: How many atoms combine to form dioxygen? Answer: two Answer: fat Satisfied Relevant Figure 1: Examples of RC task and OpenQA task. for the OpenQA task (Figure 1 bottom). That\u2019s because the paragraphs to provide answer for an OpenQA question is collected from a search engine, where each retrieved para- graph is merely relevant to the question. Therefore, it con- tains many paragraphs without answer string, for instance, in Figure 1 Paragraph2.",
            "That\u2019s because the paragraphs to provide answer for an OpenQA question is collected from a search engine, where each retrieved para- graph is merely relevant to the question. Therefore, it con- tains many paragraphs without answer string, for instance, in Figure 1 Paragraph2. When applying RC models to OpenQA task, we have to omit these paragraphs in the training phase. However, during the inference phase, when model meets one paragraph without answer string, it will pick out a text span as an answer span with high con\ufb01dence, since RC model has no evidence to justify whether a paragraph contains the answer string. Secondly, they only consider the \ufb01rst answer span in the paragraph, but omit the remaining rich multiple answer spans. In RC task, the answer and its positions in the para- graph are provided by the annotator in the training data. Therefore RC models only need to consider the unique an- swer span, e.g., in SQuAD (Rajpurkar et al. 2016). How- ever, the OpenQA task only provides the answer string as the ground-truth.",
            "Therefore RC models only need to consider the unique an- swer span, e.g., in SQuAD (Rajpurkar et al. 2016). How- ever, the OpenQA task only provides the answer string as the ground-truth. Therefore, multiple answer spans are de- tected in the given paragraph, which cannot be considered by the traditional RC models. Take Figure 1 as an example, all text spans contain \u2018fat\u2019 are treated as answer span, so we detect two answer spans in Paragraph1. Thirdly, they assume that the start position and end posi- arXiv:1901.03866v1  [cs.CL]  12 Jan 2019",
            "Answer Span Paragraph Paragraph Answer Span Answer Span \u2026\u2026 Paragraph (No Ans) \u2026\u2026 Paragraph (No Ans) Start Location End Location Span Level Paragraph Level Question Level Answer Answer Prob. = \u03a3 Paragraph Prob. \u2a09Conditional Answer Prob. Conditional Answer Prob. = F( Span Prob. ) Span Prob. = Start Prob. \u2a09End Prob. F Figure 2: The three hierarchical levels of OpenQA task. tion of an answer span is independent. However, the end po- sition is evidently related with the start position, especially when there are multiple answer spans in a paragraph. There- fore, it may introduce some problems when using such in- dependence assumption. For example, the detected end pos- ition may correspond to another answer span, rather than the answer span located by the start position. In Figure 1 Para- graph1, \u2018fat in their \u00b7 \u00b7 \u00b7 insulating effect fat\u2019 has a high con- \ufb01dence to be an answer span under independence assump- tion.",
            "In Figure 1 Para- graph1, \u2018fat in their \u00b7 \u00b7 \u00b7 insulating effect fat\u2019 has a high con- \ufb01dence to be an answer span under independence assump- tion. In this paper, we propose a Hierarchical Answer Span Model, named HAS-QA, based on a new three-level prob- abilistic formulation of OpenQA task, as shown in Figure 2. At the question level, the conditional probability of the an- swer string given a question and a collection of paragraphs, named answer probability, is de\ufb01ned as the product of the paragraph probability and conditional answer probability, based on the law of total probability. At the paragraph level, paragraph probability is de\ufb01ned as the degree to which a paragraph can answer the question. This probability is used to measure the quality of a para- graph and targeted to tackle the \ufb01rst problem mentioned, i.e. identify the useless paragraphs. For calculation, we \ufb01rst apply bidirectional GRU and an attention mechanism on the question aware context embedding to obtain a score. Then, we normalize the scores across the multiple para- graphs. In the training phase, we adopt a negative sampling strategy for optimization.",
            "identify the useless paragraphs. For calculation, we \ufb01rst apply bidirectional GRU and an attention mechanism on the question aware context embedding to obtain a score. Then, we normalize the scores across the multiple para- graphs. In the training phase, we adopt a negative sampling strategy for optimization. Conditional answer probability is the conditional probability that a text string is the answer given the paragraph. Considering multiple answer spans in a paragraph, the conditional answer probability can be fur- ther represented as the aggregation of several span probab- ility, de\ufb01ned later. In this paper, four types of functions, i.e. HEAD, RAND, MAX and SUM, are used for aggregation. At the span level, span probability represents the probab- ility that a text span in a paragraph is the answer span. Simil- arly to previous work (Wang and Jiang 2016), span probabil- ity can be computed as the product of two location probabil- ity, i.e., location start probability and location end probabil- ity.",
            "Simil- arly to previous work (Wang and Jiang 2016), span probabil- ity can be computed as the product of two location probabil- ity, i.e., location start probability and location end probabil- ity. Then a conditional pointer network is proposed to model the probabilistic dependences between the start and end po- sitions, by making generation of end position depended on the start position directly, rather than internal representation of start position (Vinyals, Fortunato, and Jaitly 2015). The contributions of this paper include: 1) a probabilistic formulation of the OpenQA task, based on the a three-level hierarchical structure, i.e. the question level, the paragraph level and the answer span level; 2) the proposal of an end-to-end HAS-QA model to implement the three-level probabilistic formulation of OpenQA task (Section 4), which tackles the three problems of direct applying existing RC models to OpenQA; 3) extensive experiments on QuasarT, TriviaQA and SearchQA datasets, which show that HAS-QA outperforms traditional RC baselines and recent OpenQA baselines.",
            "2 Related Works Research in reading comprehension grows rapidly, and many successful RC models have been proposed (Dhingra et al. 2017; Seo et al. 2016; Wang and Jiang 2016) in this area. Recently, some works have treated OpenQA task as an RC task and directly applied existing RC models. In this section, we \ufb01rst review the approach of typical RC models, then introduce some recent OpenQA models which are dir- ectly based on the RC approach. RC models typically have two components: context en- coder and answer decoder. Context encoder is used to ob- tain the embeddings of questions, paragraphs and their in- teractions. Most of recent works are based on the atten- tion mechanism and its extensions. The ef\ufb01cient way is to treat the question as a key to attention paragraph (Wang and Jiang 2016; Chen et al. 2017). Adding the attention from paragraph to question (Seo et al. 2016; Xiong, Zhong, and Socher 2016), enriches the representations of context encoder. Some works (Wang et al.",
            "2017). Adding the attention from paragraph to question (Seo et al. 2016; Xiong, Zhong, and Socher 2016), enriches the representations of context encoder. Some works (Wang et al. 2017; Pan et al. 2017; Clark and Gardner 2018) \ufb01nd that self-attention is use- ful for RC task. Answer decoder aims to generate an- swer string based on the context embeddings. There ex- ist two sorts of approaches, generate answer based on the entail word vocabulary (Tan et al. 2018) and retrieve an- swer from the current paragraph. Almost all works in RC task choose the retrieval-based method. Some of them use two independently position classi\ufb01ers (Chen et al. 2017; Weissenborn, Wiese, and Seiffe 2017), the others use the pointer networks (Wang and Jiang 2016; Seo et al. 2016; Wang et al. 2017; Pan et al. 2017). An answer length limita- tion is applied in these models, i.e.",
            "2016; Wang et al. 2017; Pan et al. 2017). An answer length limita- tion is applied in these models, i.e. omit the text span longer than 8. We \ufb01nd that relaxing length constrain leads to per- formance drop. Some recent works in OpenQA research directly in- troduce RC model to build a pure data driven pipline. DrQA (Chen et al. 2017) is the earliest work that applies RC model in OpenQA task. However, its RC model is trained using typical RC dataset SQuAD (Rajpurkar et al. 2016), which turns to be over-con\ufb01dence about its predicted res- ults even if the candidate paragraphs contain no answer span. R3 (Wang et al. 2018) introduces a ranker model to rerank the original paragraph list, so as to improve the in- put quality of the following RC model. The training data of the RC model is solely limited to the paragraphs containing the answer span and the \ufb01rst appeared answer span loca- tion is chosen as the ground truth.",
            "The training data of the RC model is solely limited to the paragraphs containing the answer span and the \ufb01rst appeared answer span loca- tion is chosen as the ground truth. Shared-Norm (Clark and Gardner 2018) applied a shared-norm trick which considers paragraphs without answer span in training RC models. The",
            "trained RC model turns to be robust for the useless para- graphs and generates the lower span scores for them. How- ever, it assumes that the start and the end positions of an answer span are independent, which is not suitable for mod- eling multiple answer spans in one paragraph. Therefore, we realize that the existing OpenQA models rarely consider the differences between RC and OpenQA task. In this paper, we directly model the OpenQA task based on a probabilistic formulation, in order to identify the use- less paragraphs and utilize the multiple answer spans. 3 Probabilistic Views of OpenQA In OpenQA task, the question Q and its answer string A are given. Entering question Q into a search engine, top K relevant paragraphs are returned, denote as a list P = [P1, . . . , PK]. The target of OpenQA is to \ufb01nd the max- imum probability of P(A|Q, P), named answer probability for short.",
            ". . , PK]. The target of OpenQA is to \ufb01nd the max- imum probability of P(A|Q, P), named answer probability for short. We can see the following three characteristics of OpenQA: 1) we cannot guarantee that paragraph retrieved by search engine contains the answer span for the question, so the paragraphs without answer span have to be deleted when us- ing the above RC models. However, these paragraphs are useful for distinguishing the quality of paragraphs in train- ing. More importantly, the quality of a paragraph plays an important role in determining the answer probability in the inference phase. It is clear that directly applying RC models fails to meet this requirement. 2) only answer string is provided, while the location of the answer string is unknown. That means there may be many answer spans in the paragraph. It is well known that tradi- tional RC models are only valid for a single answer span. To tackle this problem, the authors of (Joshi et al. 2017) propose a distantly supervised method to use the \ufb01rst ex- act match location of answer string in the paragraph as the ground-truth answer span.",
            "To tackle this problem, the authors of (Joshi et al. 2017) propose a distantly supervised method to use the \ufb01rst ex- act match location of answer string in the paragraph as the ground-truth answer span. However, this method omit the valuable multiple answer spans information, which may be important for the calculation of the answer probability. 3) the start and end positions are coupled together to de- termine a speci\ufb01c answer span, since there may be multiple answer spans. However, existing RC models usually assume that the start and end positions are independent. That\u2019s be- cause there is only one answer span in the RC scenario. This may introduce serious problem in the OpenQA task. For ex- ample, if we do not consider the relations between the start and end position, the end position may be another answer span\u2019s end position, instead of the one determined by the start position. Therefore, it is not appropriate to assume in- dependence between start and end positions. In this paper, we propose to tackle the above three prob- lems. Firstly, according to the law of total probability, the answer probability can be rewritten as the following form.",
            "Therefore, it is not appropriate to assume in- dependence between start and end positions. In this paper, we propose to tackle the above three prob- lems. Firstly, according to the law of total probability, the answer probability can be rewritten as the following form. P(A|Q, P)= K X i=1 P(Pi|Q, P)P(A|Q, Pi). (1) We name P(Pi|Q, P) and P(A|Q, Pi) as the paragraph probability and conditional answer probability, respectively. We can see that the paragraph probability measures the quality of paragraph Pi across the list P, while the con- ditional answer probability measures the probability that string A is an answer string given paragraph Pi. The conditional answer probability can be treated as a function of multiple span probabilities {P(Lj(A)|Q, Pi)}j, as shown in Eq 2.",
            "The conditional answer probability can be treated as a function of multiple span probabilities {P(Lj(A)|Q, Pi)}j, as shown in Eq 2. P(A|Q, Pi) := F({P(Lj(A)|Q, Pi)}j), j \u2208[1, |L(A, Pi)|], (2) where the aggregation function F treats a list of spans L(A, Pi) as input, and |L(A, Pi)| denotes the number of the text spans contain the string A. A proper aggregation function makes use of all the answer spans information in OpenQA task. Previous work (Joshi et al. 2017) can be treated as a special case, which uses a function of selecting \ufb01rst match span as the aggregation function F. The span probability P(Lj(A)|Q, Pi) represents the probability that a text span Lj(A) in the paragraph Pi is an answer span. We further decompose it into the product of location start probability P(Ls j(A)|Q, Pi) and location end probability P(Le j(A)|Q, Pi, Ls j(A)), shown in Eq 3.",
            "We further decompose it into the product of location start probability P(Ls j(A)|Q, Pi) and location end probability P(Le j(A)|Q, Pi, Ls j(A)), shown in Eq 3. P(Lj(A)|Q, Pi) =P(Ls j(A)|Q, Pi) \u00b7P(Le j(A)|Q, Pi, Ls j(A)). (3) Some previous work such as DrQA (Chen et al. 2017) treats them as the two independently position classi\ufb01cation tasks, thus Ls(A) and Le(A) are modeled by two differ- ent functions. Match-LSTM (Wang and Jiang 2016) treats them as the pointer networks (Vinyals, Fortunato, and Jaitly 2015). The difference is that Le(A) is the function of the hidden state of Ls(A), denote as Ms. However, Ls(A) and Le(A) are still independent in probabilistic view, because Le(A) depends on the hidden state Ms, not the start po- sition Ls(A).",
            "However, Ls(A) and Le(A) are still independent in probabilistic view, because Le(A) depends on the hidden state Ms, not the start po- sition Ls(A). In this paper, the span positions Ls j(A) and Le j(A) are determined by the question Q and the paragraph Pi. Specially, end position Le j(A) is also conditional on start position Ls j(A) directly. With this conditional probability, we can naturally remove the answer length limitation. With above formulation, we \ufb01nd that RC task is a special case of OpenQA task, where we set the num- ber of paragraph K to 1, set the paragraph probability to constant number 1, treat P(A|Q, P)=P(L(A)|Q, P), P(L(A)|Q, P)=P(Ls(A)|Q, P)P(Le(A)|Q, P), where P is the idealized paragraph that contain the answer string A, and the right position L(A) is also known.",
            "4 HAS-QA Model In this section, we propose a Hierarchical Answer Span Model (HAS-QA) for OpenQA task, based on the probabil- istic view of OpenQA in Section 3. HAS-QA has four com- ponents: question aware context encoder, conditional span predictor, multiple spans aggregator and paragraph quality estimator. We will introduce them one by one. 4.1 Question Aware Context Encoder The question aware context embeddings C is generated by the context encoder, while HAS-QA do not limit the use",
            "of context encoder. We choose a simple but ef\ufb01cient con- text encoder in this paper. It takes advantage of previous works (Clark and Gardner 2018; Wang and Jiang 2016), which contains the character-level embedding enhancement, the bi-directional attention mechanism (Seo et al. 2016) and the self-attention mechanism (Wang et al. 2017). We brie\ufb02y describe the process below 2. Word Embeddings: use size 300 pre-trained GloVe (Pen- nington, Socher, and Manning 2014) word embeddings. Char Embeddings: encode characters in size 20, which are learnable. Then obtain the embedding of each word by convolutional layer and max pooling layer. Context Embeddings: concatenate word embeddings and char embeddings, and apply bi-directional GRU (Cho et al. 2014) to obtain the context embeddings. Both question and paragraph get their own context embeddings. Question Aware Context Embeddings: use bi- directional attention mechanism from the BiDAF (Seo et al. 2016) to build question aware context embeddings.",
            "2014) to obtain the context embeddings. Both question and paragraph get their own context embeddings. Question Aware Context Embeddings: use bi- directional attention mechanism from the BiDAF (Seo et al. 2016) to build question aware context embeddings. Additionally, we subsequently apply a layer of self-attention to get the \ufb01nal question aware context embeddings. After the processes above, we get the \ufb01nal question aware context embeddings, denoted C \u2208Rn\u00d7r, where n is the length of the paragraph and r is size of the embedding. 4.2 Conditional Span Predictor Conditional span predictor de\ufb01nes the span probability for each text span in a paragraph using a conditional pointer net- work. We \ufb01rst review the answer decoder in traditional RC mod- els. It mainly has two types: two independently position classi\ufb01ers (IndCls) and the pointer networks (PtrNet). Both of these approaches generate a distribution of start position ps \u2208Rn and a distribution of end position pe \u2208Rn, where n is the length of the paragraph.",
            "It mainly has two types: two independently position classi\ufb01ers (IndCls) and the pointer networks (PtrNet). Both of these approaches generate a distribution of start position ps \u2208Rn and a distribution of end position pe \u2208Rn, where n is the length of the paragraph. Starting from the con- text embeddings C, two intermedia representations Ms \u2208 Rn\u00d72d and Me \u2208Rn\u00d72d are generated using two bidirec- tional GRUs with the output dimension d. Ms = BiGRU(C) (4) IndCls: Me = BiGRU(C), (5) PtrNet: Me = BiGRU([C, Ms]). (6) Then an additional Softmax function is used to generate the \ufb01nal positional distributions, ps =softmax(Msws), pe =softmax(Mewe). (7) where ws, we \u2208R2d denotes the linear transformation para- meters. As mentioned in Section 3, IndCls and PtrNet both treat start and end position as probabilistic independent. Given the independent start and end positions can not distinguish the different answer spans in a paragraph properly, so it is necessary to build a conditional model for them.",
            "As mentioned in Section 3, IndCls and PtrNet both treat start and end position as probabilistic independent. Given the independent start and end positions can not distinguish the different answer spans in a paragraph properly, so it is necessary to build a conditional model for them. Therefore, we proposed a conditional pointer network which directly 2For more detailed computational steps, see reference paper (Clark and Gardner 2018). feed the start position to the process of generating the end position: Me j = BiGRU([C, Ms, OneHot(Ls j)]), pe j = softmax(Me j we), (8) where Ls j denotes the start position selected from the start positional distribution ps and OneHot(\u00b7) denotes the trans- formation from a position index to an one-hot vector. In the training phase, we are given the start and end pos- itions of each answer span, denote as Ls j and Le j. The span probability is: P(Lj(A)|Q, Pi) = sj = ps[Ls j] \u00b7 pe j [Le j]. (9) In the inference phase, we \ufb01rst select the start position Ls j from the start distribution ps.",
            "(9) In the inference phase, we \ufb01rst select the start position Ls j from the start distribution ps. Then we yield its correspond- ing end distribution pe j using Eq 8, and select the end pos- ition Le j from it. Finally, we get the span probability using Eq 9. 4.3 Multiple Spans Aggregator Multiple span aggregator is used to build the relations among multiple answer spans and outputs the conditional answer probability. In this paper, we design four types of aggregation functions F: HEAD: P(A|Q, Pi) = s1 RAND: P(A|Q, Pi) = Random(sj) MAX: P(A|Q, Pi) = maxj(sj) SUM: P(A|Q, Pi) = X j(sj) (10) where sj denotes the span probability de\ufb01ned in Eq 9, s1 denotes the \ufb01rst match answer span and Random denotes a stochastic function for randomly choosing an answer span. Different aggregation functions represent different as- sumptions about the distribution of the oracle answer spans in a paragraph.",
            "Different aggregation functions represent different as- sumptions about the distribution of the oracle answer spans in a paragraph. The oracle answer span represents the an- swer of the question that can be merely determined by its context, e.g. in Figure 1, the \ufb01rst answer span \u2018fat\u2019 is the or- acle answer span, while the second one is not, because we could retrieval the answer directly, if we have read \u2018concen- trating body fat in their humps\u2019. HEAD operation simply chooses the \ufb01rst match span probability as the conditional answer probability, which simulates the answer preprocessing in previous works (Wang et al. 2018; Joshi et al. 2017). This function only encourages the \ufb01rst match answer span as the oracle, while punishes the others. It can be merely worked in a para- graph with de\ufb01nition, such as \ufb01rst paragraph in WikiPedia. RAND operation randomly chooses a span probability as the conditional answer probability. This function assumes that all answer spans are equally important, and must be treated as oracle. However, balancing the probabilities of an- swer spans is hard.",
            "RAND operation randomly chooses a span probability as the conditional answer probability. This function assumes that all answer spans are equally important, and must be treated as oracle. However, balancing the probabilities of an- swer spans is hard. It can be used in paraphrasing answer spans appear in a list. MAX operation chooses the maximum span probability as the conditional answer probability. This function assumes that only one answer span is the oracle. It can be used in a",
            "noisy paragraph, especially for those retrieved by a search engine. SUM operation sums all the span probabilities as the con- ditional answer probability. This function assumes that one or more answer spans are the oracle. It can be used in a broad range of scenarios, for its relatively weak assumption. In the training phase, all annotated answer spans contain the same answer string A, we directly apply the Eq 10 to obtain the conditional answer probability in paragraph level. In the inference phase, we treat the top K span prob- abilities sj as the input of the aggregation function. How- ever, we have to check all possible start and end positions to get the precise top K span probabilities. Instead, we use a beam search strategy (Sutskever, Vinyals, and Le 2014) which only consider the top K1 start positions and the top K2 end positions, where K1K2 \u2265K. Different span prob- abilities sj represent variance answer strings At. Following the de\ufb01nition in Eq 10, we group them by different answer strings respectively.",
            "Different span prob- abilities sj represent variance answer strings At. Following the de\ufb01nition in Eq 10, we group them by different answer strings respectively. 4.4 Paragraph Quality Estimator Paragraph quality estimator takes the useless paragraphs into consideration, which implements the paragraph probability P(Pi|Q, P) directly. Firstly, we use an attention-based network to generate a quality score, denotes as \u02c6qi, in order to measure the quality of the given paragraph Pi. Mc = BiGRU(C), \u02c6qi = (Mc\u22a4\u00b7 ps) \u00b7 wc. (11) where Mc \u2208Rn\u00d72d is the intermedia representation ob- tained by applying bidirectional GRU on the context embed- ding C. Then, let start distribution ps \u2208Rn as a key to at- tention Mc and transform it to 1-d value using weight wc \u2208 R2d. Finally, we get the quality score \u02c6qi.",
            "Finally, we get the quality score \u02c6qi. Paragraph probab- ilities P(Pi|Q, P) are generated by normalizing across P, P(Pi|Q, P)=qi = exp(\u02c6qi) P Pj\u2208P exp(\u02c6qj). (12) In the training phase, we conduct a negative sampling strategy with one negative sample, for ef\ufb01cient training. Thus a pair of paragraphs, P + as positive and P \u2212as negat- ive, are used to approximate q+ \u2248P(P +|Q, [P +, P \u2212]) and q\u2212\u2248P(P \u2212|Q, [P +, P \u2212]). In the inference phase, the probability qi is obtained by normalizing across all the retrieved paragraphs P. Above all, we describe our model with Algorithm 1 in the training phase and Algorithm 2 in the inference phase. 5 Experiments 5.1 Datasets We evaluate our model on three OpenQA datasets, Quas- arT (Dhingra, Mazaitis, and Cohen 2017), TriviaQA (Joshi et al.",
            "5 Experiments 5.1 Datasets We evaluate our model on three OpenQA datasets, Quas- arT (Dhingra, Mazaitis, and Cohen 2017), TriviaQA (Joshi et al. 2017) and SearchQA (Dunn et al. 2017). QuasarT3: consists of 43k open-domain trivia ques- tions whose answers obtained from various internet sources.",
            "2017) and SearchQA (Dunn et al. 2017). QuasarT3: consists of 43k open-domain trivia ques- tions whose answers obtained from various internet sources. 3https:\/\/github.com\/bdhingra\/quasar Algorithm 1 HAS-QA Model in Training Phase Require: Q: question; A: answer string; P: retrieved paragraphs; Ensure: L: loss function 1: for P +, P \u2212in P do: 2: Get answer locations Ls, Le for P +; 3: Get the context embedding C; 4: Compute ps; (Eq 7) 5: for Ls j, Le j in Ls, Le do: 6: ps j \u2190ps[Ls j]; 7: Compute pe j ; (Eq 8) 8: pe j \u2190pe j [Le j]; 9: sj \u2190ps jpe j; 10: Apply function: p+ \u2190F({sj}); 11: Compute q+ in [P +, P \u2212]; (Eq 11, Eq 12) 12: Li \u2190\u2212(log(q+) + log(p+)); 13: L \u2190Avg({Li}).",
            "Algorithm 2 HAS-QA Model in Inference Phase Require: Q: question; P: retrieved paragraphs; Ensure: Abest: answer string 1: for Pi in P do: 2: Get the context embedding C; 3: Compute ps; (Eq 7) 4: for Ls j in Top-K1 ps do: 5: ps j \u2190ps[Ls j]; 6: Compute pe j ; (Eq 8) 7: for Le jk in Top-K2 pe j do: 8: pe jk \u2190pe j [Le jk]; 9: sjk \u2190ps jpe jk; 10: Group sjk by extracted answer string At; 11: Apply function: pAt i \u2190F({sjk}At); 12: Compute \u02c6qi; (Eq 11) 13: Normalize {\u02c6qi} get {qi}; (Eq 12) 14: S(At) \u2190P i qi \u00b7 pAt i ; 15: Abest \u2190arg max(S(At)). ClueWeb09 (Callan et al. 2009) serves as the background corpus for providing evidences paragraphs.",
            "ClueWeb09 (Callan et al. 2009) serves as the background corpus for providing evidences paragraphs. We choose the Long version, which is truncated to 2048 characters and 20 paragraphs for each question. TriviaQA4: consists of 95k open-domain question- answer pairs authored by trivia enthusiasts and independ- ently gathered evidence documents from Bing Web Search and Wikipedia, six per question on average. We focus on the open domain setting contains un\ufb01ltered documents. SearchQA5: is based on a Jeopardy! questions and col- lects about top 50 web page snippets from Google search engine for each question. As we can see in Table 1, there exist amounts of negat- ive paragraphs which contains no answer span, especially in TriviaQA and SearchQA. For all datasets, more than 4http:\/\/nlp.cs.washington.edu\/triviaqa\/ 5https:\/\/github.com\/nyu-dl\/SearchQA",
            "Dataset Neg Para. Ratio Avg Ans. Span Count QuasarT 1.21% 5.09 TriviaQA 37.24% 4.20 SearchQA 25.06% 6.80 Table 1: The negative paragraph ratio and average answer span count are statistic on three datasets, in order to illustrate the problems mentioned above in OpenQA task. 4 answer spans averagely obtained per paragraph. These statistics illustrate that problems mentioned above exist in OpenQA datasets. 5.2 Experimental Settings For RC baseline models GA (Dhingra et al. 2017), BiDAF (Seo et al. 2016) and AQA (Buck et al. 2017), their experi- mental results are collected from published papers (Dunn et al. 2017; Joshi et al. 2017). The DrQA (Chen et al. 2017), R3 (Wang et al. 2018) and Shared-Norm (Clark and Gardner 2018) are evaluated using their released code6. Our model 7 adopts the same data preprocessing and ques- tion context encoder presented in (Clark and Gardner 2018).",
            "2017), R3 (Wang et al. 2018) and Shared-Norm (Clark and Gardner 2018) are evaluated using their released code6. Our model 7 adopts the same data preprocessing and ques- tion context encoder presented in (Clark and Gardner 2018). In training step, we use the Adadelta optimizer (Zeiler 2012) with the batch size of 30, and we choose the model per- formed the best on develop set 8. The hidden dimension of GRU is 200, and the dropout ratio is 0.8. We use 300 dimen- sional word embeddings pre-trained by GloVe (released by (Pennington, Socher, and Manning 2014)) and do not \ufb01ne- tune in training step. Additionally, 20 dimensional charac- ter embeddings are left as learnable parameters. In inference step, for baseline models we set the answer length limitation to 8, while for our models it is unlimited. We analyze differ- ent answer length limitation settings in the Section 5.4. The parameters of beam search are K1 = 3 and K2 = 1.",
            "In inference step, for baseline models we set the answer length limitation to 8, while for our models it is unlimited. We analyze differ- ent answer length limitation settings in the Section 5.4. The parameters of beam search are K1 = 3 and K2 = 1. 5.3 Overall Results The experimental results on three OpenQA datasets are shown in Table 2. It concludes as follow: 1) HAS-QA outperforms traditional RC baselines with a large gap, such as GA, BiDAF, AQA listed in the \ufb01rst part. For example, in QuasarT, it improves 16.8% in EM score and 20.4% in F1 score. As RC task is just a spe- cial case of OpenQA task. Some experiments on stand- ard SQuAD dataset(dev-set) (Rajpurkar et al. 2016) show that HAS-QA yields EM\/F1:0.719\/0.798, which is compar- able with the best released single model Reinforced Mne- monic Reader (Hu et al.",
            "2016) show that HAS-QA yields EM\/F1:0.719\/0.798, which is compar- able with the best released single model Reinforced Mne- monic Reader (Hu et al. 2017) in the leaderboard (dev-set) EM\/F1:0.721\/0.816. Our performance is slightly worse be- cause Reinforced Mnemonic Reader directly use the accur- ate answer span, while we use multiple distantly supervised 6DrQA: https:\/\/github.com\/facebookresearch\/DrQA. R3: https:\/\/github.com\/shuohangwang\/mprc. Shared-Norm: https:\/\/github.com\/allenai\/document-qa. 7The code will be released at https:\/\/gitlab.com\/pl8787\/has-qa. 8QuasarT and SearchQA have of\ufb01cial develop set and test set, while TriviaQA\u2019s test set is unknown, thus we split a develop set from train set and evaluate on of\ufb01cial develop set.",
            "8QuasarT and SearchQA have of\ufb01cial develop set and test set, while TriviaQA\u2019s test set is unknown, thus we split a develop set from train set and evaluate on of\ufb01cial develop set. 4 8 16 32 64 128 \u221e Answer Length Limitation 0.38 0.39 0.40 0.41 0.42 0.43 0.44 EM performance Shared-Norm HAS-QA 4 8 16 32 64 128 \u221e Answer Length Limitation 0 2 4 6 8 10 12 14 16 Predicted Answer Length Shared-Norm HAS-QA Oracle Example: About Celebrating the contributions of Louis Braille January 5th , 2009 On the 200th anniversary of Louis Braille \u2018 s birth , people around the world are saluting a man whose tactile alphabet has provided a lifeline to people with impaired vision . Shared-Norm HAS-QA Figure 3: Results of Shared-Norm and HAS-QA on Quas- arT.",
            "Shared-Norm HAS-QA Figure 3: Results of Shared-Norm and HAS-QA on Quas- arT. TopLeft: EM performance against answer length lim- itation, TopRight: predicted answer length against answer length limitation, Bottom: an example of a paragraph and the predicted answer spans of two models. answer spans. That may introduce noises in the setting of SQuAD, since only one span is accurate. 2) HAS-QA outperforms recent OpenQA baselines, such as DrQA, R3 and Shared-Norm listed in the second part. For example, in QuasarT, it improves 4.6% in EM score and 3.5% in F1 score. 5.4 Model Analysis In this subsection, we analyze our model by answering the following \ufb01ne-grained analytic questions: 1) What advantages does HAS-QA have via modeling an- swer span using the conditional pointer network? 2) How much does HAS-QA gain from modeling multiple answer spans in a paragraph? 3) How does the paragraph quality work in HAS-QA? The following three parts are used to answer these ques- tions respectively.",
            "2) How much does HAS-QA gain from modeling multiple answer spans in a paragraph? 3) How does the paragraph quality work in HAS-QA? The following three parts are used to answer these ques- tions respectively. Effects of Conditional Pointer Networks In order to demonstrate the effect of the conditional pointer networks, we compare Shared-Norm, which uses pointer networks, with our model. Then, we gradually remove the answer length limitation, from restricting 4 words to 128 words until no limitation (denote as \u221e). Finally, we draw the tendency of the EM performance and average predicted answer length according to the different answer length limitations. As shown in Figure 3 (TopLeft), the performance of Shared-Norm decreases when removing the answer length limitation, while the performance of HAS-QA \ufb01rst increases then becomes stable. In Figure 3 (TopRight), we \ufb01nd that the average predicted answer length increases in Shared- Norm when removing the answer length limitation. How- ever, our model stably keeps average about 1.8 words, where the oracle average answer length is about 1.9 words.",
            "In Figure 3 (TopRight), we \ufb01nd that the average predicted answer length increases in Shared- Norm when removing the answer length limitation. How- ever, our model stably keeps average about 1.8 words, where the oracle average answer length is about 1.9 words. Ex- ample in Figure 3 (Bottom) illustrates that start\/end point- ers in Shared-Norm search their own optimal positions in- dependently, such as two \u2018Louis\u2019 in paragraph. It leads to an unreasonable answer span prediction.",
            "QuasarT TriviaQA SearchQA Model EM F1 EM F1 EM F1 GA (Dhingra et al. 2017) 0.264 0.264 - - - - BiDAF (Seo et al. 2016) 0.259 0.285 0.411 0.474 0.286 0.346 AQA (Buck et al. 2017) - - - - 0.387 0.456 DrQA (Chen et al. 2017) 0.377 0.445 0.323 0.383 0.419 0.487 R3 (Wang et al. 2018) 0.353 0.417 0.473 0.537 0.490 0.553 Shared-Norm (Clark and Gardner 2018) 0.386 0.454 0.613 0.672 0.598 0.671 HAS-QA (MAX Ans.",
            "Span) 0.432 0.489 0.636 0.689 0.627 0.687 Table 2: Experimental results on OpenQA datasets QuasarT, TriviaQA and SearchQA. EM: Exact Match. Model EM F1 HAS-QA (HEAD Ans. Span) 0.372 0.425 HAS-QA (RAND Ans. Span) 0.341 0.394 HAS-QA (SUM Ans. Span) 0.423 0.484 HAS-QA (MAX Ans. Span) 0.432 0.489 Table 3: Results on QuasarT with different types of aggreg- ation functions (K1 = 3, K2 = 1). Effects of Multiple Spans Aggregation The effects of utilizing multiple answer spans lay into two aspects, 1) choose the aggregation functions in training phase, and 2) select the parameters of beam search in inference phase. In the training phase, we evaluate four types of aggrega- tion functions introduced in Section 4.3. The experimental results on QuasarT dataset, shown in Table 3, demonstrate the superiority of SUM and MAX operations.",
            "In the training phase, we evaluate four types of aggrega- tion functions introduced in Section 4.3. The experimental results on QuasarT dataset, shown in Table 3, demonstrate the superiority of SUM and MAX operations. They take ad- vantages of using multiple answer spans for training and im- prove about 6% - 10% in EM comparing to the HEAD op- eration. The performance of MAX operation is a little bet- ter than the SUM operation. The failure of RAND opera- tion, mainly comes down to the con\ufb02icting training samples. Therefore, simple way to make use of multiple answer spans may not improve the performance. In the inference phase, Table 4 shows the effects of para- meters in beam search. We \ufb01nd that the larger K1 yields the better performance, while K2 seems irrelevant to the performance. As a conclusion, we choose the parameters K1 = 3, K2 = 1 to balance the performance and the speed. Effects of Paragraph Quality The paragraph probability is ef\ufb01cient to measure the quality of paragraphs, especially for that containing useless paragraphs.",
            "As a conclusion, we choose the parameters K1 = 3, K2 = 1 to balance the performance and the speed. Effects of Paragraph Quality The paragraph probability is ef\ufb01cient to measure the quality of paragraphs, especially for that containing useless paragraphs. Figure 4 (Left) shows that with the increasing number of given paragraphs which ordered by the rank of a search engine, EM performance of HAS-QA sustainably grows. However, EM performance of Shared-Norm stops increas- ing at about 15 paragraphs and our model without para- graph quality (denotes PosOnly) stops increasing at about 5 paragraphs. So that with the help of paragraph probab- ility, model performance can be improved by adding more evidence paragraphs. We also evaluate the Mean Average Precision (MAP) score between the predicted scores and the label whether a paragraph contains answer spans (Figure 4 (Right)).",
            "So that with the help of paragraph probab- ility, model performance can be improved by adding more evidence paragraphs. We also evaluate the Mean Average Precision (MAP) score between the predicted scores and the label whether a paragraph contains answer spans (Figure 4 (Right)). The paragraph probability in our model outperforms PosOnly K1-K2 EM F1 K1-K2 EM F1 1-1 0.428 0.483 1-1 0.428 0.483 1-3 0.428 0.484 3-1 0.432 0.489 1-5 0.428 0.484 5-1 0.431 0.488 3-3 0.431 0.489 5-5 0.431 0.489 Table 4: Results on QuasarT with different beam search parameters K1-K2.",
            "2 4 6 8 10 12 14 16 18 20 Number of Paragraphs 0.25 0.30 0.35 0.40 0.45 EM performance PosOnly Shared-Norm HAS-QA PosOnly Shared-Norm HAS-QA Model 0.60 0.61 0.62 0.63 0.64 0.65 Paragraph MAP 0.618 0.619 0.631 Figure 4: Results of PosOnly, Shared-Norm and HAS-QA on QuasarT. Left: EM performance against number of para- graphs, Right: paragraph MAP on different models. and Shared-Norm, so that it can rank the high quality para- graphs in the front of the given paragraph list. 6 Conclusions In this paper, we point out three distinct characteristics of OpenQA, which make it inappropriate to directly apply ex- isting RC models to this task. In order to tackle these prob- lems, we \ufb01rst propose a new probabilistic formulation of OpenQA, where the answer probability is written as the question, paragraph and span, three-level structure.",
            "In order to tackle these prob- lems, we \ufb01rst propose a new probabilistic formulation of OpenQA, where the answer probability is written as the question, paragraph and span, three-level structure. In this formulation, RC can be treated as a special case. Then, Hier- archical Answer Spans Model (HAS-QA) is designed to im- plement this structure. Speci\ufb01cally, a paragraph quality es- timator makes it robust for the paragraphs without answer spans; a multiple span aggregator points out that it is neces- sary to combine the contributions of multiple answer spans in a paragraph, and a conditional span predictor is proposed to model the dependence between the start and end positions of each answer span. Experiments on public OpenQA data- sets, including QuasarT, TriviaQA and SearchQA, show that HAS-QA signi\ufb01cantly outperforms traditional RC baselines and recent OpenQA baselines.",
            "Acknowledgments This work was funded by the National Natural Science Foundation of China (NSFC) under Grants No. 61773362, 61425016, 61472401, 61722211, and 61872338, the Youth Innovation Promotion Association CAS under Grants No. 20144310, and 2016102, and the National Key R&D Pro- gram of China under Grants No. 2016QY02D0405. References [Berant et al. 2013] Berant, J.; Chou, A.; Frostig, R.; and Li- ang, P. 2013. Semantic parsing on freebase from question- answer pairs. In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, 1533\u2013 1544. [Buck et al. 2017] Buck, C.; Bulian, J.; Ciaramita, M.; Ges- mundo, A.; Houlsby, N.; Gajewski, W.; and Wang, W. 2017. Ask the right questions: Active question reformulation with reinforcement learning. arXiv preprint arXiv:1705.07830.",
            "2017. Ask the right questions: Active question reformulation with reinforcement learning. arXiv preprint arXiv:1705.07830. [Callan et al. 2009] Callan, J.; Hoy, M.; Yoo, C.; and Zhao, L. 2009. Clueweb09 data set. [Chen et al. 2017] Chen, D.; Fisch, A.; Weston, J.; and Bordes, A. 2017. Reading wikipedia to answer open-domain questions. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, 1870\u20131879. [Cho et al. 2014] Cho, K.; van Merrienboer, B.; Gulcehre, C.; Bahdanau, D.; Bougares, F.; Schwenk, H.; and Bengio, Y. 2014. Learning phrase representations using rnn encoder\u2013 decoder for statistical machine translation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), 1724\u20131734.",
            "2014. Learning phrase representations using rnn encoder\u2013 decoder for statistical machine translation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), 1724\u20131734. [Clark and Gardner 2018] Clark, C., and Gardner, M. 2018. Simple and effective multi-paragraph reading comprehen- sion. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, 845\u2013855. [Dhingra et al. 2017] Dhingra, B.; Liu, H.; Yang, Z.; Cohen, W.; and Salakhutdinov, R. 2017. Gated-attention readers for text comprehension. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, 1832\u20131846. [Dhingra, Mazaitis, and Cohen 2017] Dhingra, B.; Mazaitis, K.; and Cohen, W. W. 2017.",
            "[Dhingra, Mazaitis, and Cohen 2017] Dhingra, B.; Mazaitis, K.; and Cohen, W. W. 2017. Quasar: Datasets for ques- tion answering by search and reading. arXiv preprint arXiv:1707.03904. [Dunn et al. 2017] Dunn, M.; Sagun, L.; Higgins, M.; Guney, U.; Cirik, V.; and Cho, K. 2017. Searchqa: A new q&a dataset augmented with context from a search engine. arXiv preprint arXiv:1704.05179. [Ferrucci et al. 2010] Ferrucci, D.; Brown, E.; Chu-Carroll, J.; Fan, J.; Gondek, D.; Kalyanpur, A. A.; Lally, A.; Mur- dock, J. W.; Nyberg, E.; Prager, J.; et al. 2010. Building watson: An overview of the deepqa project. AI magazine 31(3):59\u201379. [Hu et al.",
            "2010. Building watson: An overview of the deepqa project. AI magazine 31(3):59\u201379. [Hu et al. 2017] Hu, M.; Peng, Y.; Huang, Z.; Qiu, X.; Wei, F.; and Zhou, M. 2017. Reinforced mnemonic reader for machine reading comprehension. arXiv preprint arXiv:1705.02798. [Joshi et al. 2017] Joshi, M.; Choi, E.; Weld, D.; and Zettlemoyer, L. 2017. Triviaqa: A large scale distantly su- pervised challenge dataset for reading comprehension. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, 1601\u20131611. [Mou et al. 2017] Mou, L.; Lu, Z.; Li, H.; and Jin, Z. 2017. Coupling distributed and symbolic execution for natural lan- guage queries. In International Conference on Machine Learning, 2518\u20132526. [Pan et al.",
            "2017] Mou, L.; Lu, Z.; Li, H.; and Jin, Z. 2017. Coupling distributed and symbolic execution for natural lan- guage queries. In International Conference on Machine Learning, 2518\u20132526. [Pan et al. 2017] Pan, B.; Li, H.; Zhao, Z.; Cao, B.; Cai, D.; and He, X. 2017. Memen: Multi-layer embedding with memory networks for machine comprehension. arXiv pre- print arXiv:1707.09098. [Pennington, Socher, and Manning 2014] Pennington, J.; Socher, R.; and Manning, C. 2014. Glove: Global vectors for word representation. In Proceedings of the 2014 confer- ence on empirical methods in natural language processing (EMNLP), 1532\u20131543. [Rajpurkar et al. 2016] Rajpurkar, P.; Zhang, J.; Lopyrev, K.; and Liang, P. 2016.",
            "[Rajpurkar et al. 2016] Rajpurkar, P.; Zhang, J.; Lopyrev, K.; and Liang, P. 2016. Squad: 100,000+ questions for machine comprehension of text. In Proceedings of the 2016 Con- ference on Empirical Methods in Natural Language Pro- cessing, 2383\u20132392. [Seo et al. 2016] Seo, M.; Kembhavi, A.; Farhadi, A.; and Hajishirzi, H. 2016. Bidirectional attention \ufb02ow for ma- chine comprehension. arXiv preprint arXiv:1611.01603. [Sutskever, Vinyals, and Le 2014] Sutskever, I.; Vinyals, O.; and Le, Q. V. 2014. Sequence to sequence learning with neural networks. In Advances in neural information pro- cessing systems, 3104\u20133112. [Tan et al. 2018] Tan, C.; Wei, F.; Yang, N.; Lv, W.; and Zhou, M.",
            "2014. Sequence to sequence learning with neural networks. In Advances in neural information pro- cessing systems, 3104\u20133112. [Tan et al. 2018] Tan, C.; Wei, F.; Yang, N.; Lv, W.; and Zhou, M. 2018. S-net: From answer extraction to answer generation for machine reading comprehension. In In Pro- ceedings of the 32th AAAI Conference on Arti\ufb01cial Intelli- gence. [Vinyals, Fortunato, and Jaitly 2015] Vinyals, O.; Fortunato, M.; and Jaitly, N. 2015. Pointer networks. In Advances in Neural Information Processing Systems, 2692\u20132700. [Wang and Jiang 2016] Wang, S., and Jiang, J. 2016. Ma- chine comprehension using match-lstm and answer pointer. arXiv preprint arXiv:1608.07905. [Wang et al. 2017] Wang, W.; Yang, N.; Wei, F.; Chang, B.; and Zhou, M. 2017.",
            "arXiv preprint arXiv:1608.07905. [Wang et al. 2017] Wang, W.; Yang, N.; Wei, F.; Chang, B.; and Zhou, M. 2017. Gated self-matching networks for read- ing comprehension and question answering. In Proceedings of the 55th Annual Meeting of the Association for Computa- tional Linguistics (Volume 1: Long Papers), volume 1, 189\u2013 198. [Wang et al. 2018] Wang, S.; Yu, M.; Guo, X.; Wang, Z.; Klinger, T.; Zhang, W.; Chang, S.; Tesauro, G.; Zhou, B.; and Jiang, J. 2018. R3: Reinforced reader-ranker for open- domain question answering. In In Proceedings of the 32th AAAI Conference on Arti\ufb01cial Intelligence.",
            "[Weissenborn, Wiese, and Seiffe 2017] Weissenborn, D.; Wiese, G.; and Seiffe, L. 2017. Fastqa: A simple and ef\ufb01cient neural architecture for question answering. arXiv preprint arXiv:1703.04816. [Xiong, Zhong, and Socher 2016] Xiong, C.; Zhong, V.; and Socher, R. 2016. Dynamic coattention networks for question answering. arXiv preprint arXiv:1611.01604. [Zeiler 2012] Zeiler, M. D. 2012. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701."
        ],
        "queries": "\/future\/u\/okhattab\/data\/MSMARCO\/queries.train.tsv",
        "index_name": "PaperTab-question-1901.03866.pdf",
        "overwrite": false,
        "root": ".ragatouille\/",
        "experiment": "colbert",
        "index_root": null,
        "name": "2025-05\/17\/10.22.50",
        "rank": 0,
        "nranks": 1,
        "amp": true,
        "gpus": 1,
        "avoid_fork_if_possible": false
    },
    "num_chunks": 1,
    "num_partitions": 1024,
    "num_embeddings_est": 10745.000366210938,
    "avg_doclen_est": 173.30645751953125
}
