{
  "config":{
    "query_token_id":"[unused0]",
    "doc_token_id":"[unused1]",
    "query_token":"[Q]",
    "doc_token":"[D]",
    "ncells":null,
    "centroid_score_threshold":null,
    "ndocs":null,
    "load_index_with_mmap":false,
    "index_path":null,
    "index_bsize":32,
    "nbits":4,
    "kmeans_niters":20,
    "resume":false,
    "pool_factor":1,
    "clustering_mode":"hierarchical",
    "protected_tokens":0,
    "similarity":"cosine",
    "bsize":64,
    "accumsteps":1,
    "lr":0.00001,
    "maxsteps":400000,
    "save_every":null,
    "warmup":20000,
    "warmup_bert":null,
    "relu":false,
    "nway":64,
    "use_ib_negatives":true,
    "reranker":false,
    "distillation_alpha":1.0,
    "ignore_scores":false,
    "model_name":null,
    "query_maxlen":32,
    "attend_to_mask_tokens":false,
    "interaction":"colbert",
    "dim":128,
    "doc_maxlen":256,
    "mask_punctuation":true,
    "checkpoint":"colbert-ir/colbertv2.0",
    "triples":"/future/u/okhattab/root/unit/experiments/2021.10/downstream.distillation.round2.2_score/round2.nway6.cosine.ib/examples.64.json",
    "collection":[
      "How Far are We from Effective Context Modeling? An Exploratory Study on Semantic Parsing in Context Qian Liu1\u2217, Bei Chen2, Jiaqi Guo3\u2217, Jian-Guang Lou2, Bin Zhou1 and Dongmei Zhang2 1School of Computer Science and Engineering, Beihang University, China 2Microsoft Research, Beijing, China 3Xi\u2019an Jiaotong University, Xi\u2019an, China {qian.liu, zhoubin}@buaa.edu.cn, {beichen, jlou, dongmeiz}@microsoft.com, jasperguo2013@stu.xjtu.edu.cn Abstract Recently semantic parsing in context has received considerable attention, which is challenging since there are complex contextual phenomena. Previ- ous works veri\ufb01ed their proposed methods in lim- ited scenarios, which motivates us to conduct an ex- ploratory study on context modeling methods un- der real-world semantic parsing in context. We present a grammar-based decoding semantic parser and adapt typical context modeling methods on top of it.",
      "We present a grammar-based decoding semantic parser and adapt typical context modeling methods on top of it. We evaluate 13 context modeling methods on two large complex cross-domain datasets, and our best model achieves state-of-the-art performances on both datasets with signi\ufb01cant improvements. Furthermore, we summarize the most frequent con- textual phenomena, with a \ufb01ne-grained analysis on representative models, which may shed light on po- tential research directions. Our code is available at https://github.com/microsoft/ContextualSP. 1 Introduction Semantic parsing, which translates a natural language sen- tence into its corresponding executable logic form (e.g. Struc- tured Query Language, SQL), relieves users from the burden of learning techniques behind the logic form. The majority of previous studies on semantic parsing assume that queries are context-independent and analyze them in isolation. However, in reality, users prefer to interact with systems in a dialogue, where users are allowed to ask context-dependent incomplete questions [Bertomeu et al., 2006]. That arises the task of Semantic Parsing in Context (SPC), which is quite challeng- ing as there are complex contextual phenomena.",
      "That arises the task of Semantic Parsing in Context (SPC), which is quite challeng- ing as there are complex contextual phenomena. In general, there are two sorts of contextual phenomena in dialogues: Coreference and Ellipsis [Androutsopoulos et al., 1995]. Fig- ure 1 shows a dialogue from the dataset SPARC [Yu et al., 2019b]. After the question \u201cWhat is id of the car with the max horsepower?\u201d, the user poses an elliptical question \u201cHow about with the max MPG?\u201d, and a question containing pro- nouns \u201cShow its make!\u201d. Only when completely understand- ing the context, could a parser successfully parse the incom- plete questions into their corresponding SQL queries. \u2217Work done during an internship at Microsoft Research. \ud835\udc441: What is id of the car with the max horsepower? \ud835\udc461: SELECT Id FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 \ud835\udc442: How about with the max MPG? \ud835\udc462: SELECT Id FROM CARS_DATA ORDER BY MPG DESC LIMIT 1 \ud835\udc443: Show its make!",
      "\ud835\udc461: SELECT Id FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 \ud835\udc442: How about with the max MPG? \ud835\udc462: SELECT Id FROM CARS_DATA ORDER BY MPG DESC LIMIT 1 \ud835\udc443: Show its make! \ud835\udc463: SELECT T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId = T2.Id ORDER BY T2.MPG DESC LIMIT 1 CARS_NAMES MakeId Model Make CARS_DATA Id MPG Horsepower Figure 1: An example dialogue (right) and its database schema (left). A number of context modeling methods have been sug- gested in the literature to address SPC [Iyyer et al., 2017; Suhr et al., 2018; Yu et al., 2019b; Zhang et al., 2019; Yu et al., 2019a]. These methods proposed to leverage two categories of context: recent questions and precedent logic form. It is natural to leverage recent questions as context. Taking the example from Figure 1, when parsing Q3, we also need to take Q1 and Q2 as input.",
      "These methods proposed to leverage two categories of context: recent questions and precedent logic form. It is natural to leverage recent questions as context. Taking the example from Figure 1, when parsing Q3, we also need to take Q1 and Q2 as input. We can either sim- ply concatenate the input questions, or use a model to en- code them hierarchically [Suhr et al., 2018]. As for the sec- ond category, instead of taking a sequence of recent ques- tions as input, it only considers the precedent logic form. For instance, when parsing Q3, we only need to take S2 as context. With such a context, the decoder can attend over it, or reuse it via a copy mechanism [Suhr et al., 2018; Zhang et al., 2019]. Intuitively, methods that fall into this category enjoy better generalizability, as they only rely on the last logic form as context, no matter at which turn. Notably, these two categories of context can be used simultaneously. However, it remains unclear how far we are from effec- tive context modeling.",
      "Notably, these two categories of context can be used simultaneously. However, it remains unclear how far we are from effec- tive context modeling. First, there is a lack of thorough comparisons of typical context modeling methods on com- plex SPC (e.g. cross-domain). Second, none of previ- ous works veri\ufb01ed their proposed context modeling methods with the grammar-based decoding technique, which has been proven to be highly effective in semantic parsing [Krishna- murthy et al., 2017; Yin and Neubig, 2018; Guo et al., 2019; Lin et al., 2019]. To obtain better performance, it is worth- while to study how context modeling methods collaborate with the grammar-based decoding. Last but not least, there is a limited understanding of how context modeling methods perform on various contextual phenomena. An in-depth anal- arXiv:2002.00652v2  [cs.CL]  13 Jun 2020",
      "ysis can shed light on potential research directions. In this paper, we try to ful\ufb01ll the above insuf\ufb01ciency via an exploratory study on real-world semantic parsing in context. Concretely, we present a grammar-based decoding semantic parser and adapt typical context modeling methods on top of it. Through experiments on two large complex cross-domain datasets, SPARC [Yu et al., 2019b] and COSQL [Yu et al., 2019a], we carefully compare and analyze the performance of different context modeling methods. Our best model achieves state-of-the-art (SOTA) performances on both datasets with signi\ufb01cant improvements. Furthermore, we summarize and generalize the most frequent contextual phenomena, with a \ufb01ne-grained analysis of representative models. Through the analysis, we obtain some interesting \ufb01ndings, which may bene\ufb01t the community on the potential research directions. 2 Methodology In the task of SPC, we are given a dataset composed of dia- logues. Denoting \u27e8x1, ..., xn\u27e9a sequence of natural language questions in a dialogue, \u27e8y1, ..., yn\u27e9are their corresponding SQL queries.",
      "2 Methodology In the task of SPC, we are given a dataset composed of dia- logues. Denoting \u27e8x1, ..., xn\u27e9a sequence of natural language questions in a dialogue, \u27e8y1, ..., yn\u27e9are their corresponding SQL queries. Each SQL query is conditioned on a multi-table database schema, and the databases used in test do not appear in training. In this section, we \ufb01rst present a base model with- out considering context. Then we introduce 6 typical context modeling methods and describe how we equip the base model with these methods. Finally, we present how to augment the model with BERT [Devlin et al., 2019]. 2.1 Base Model We employ the popularly used attention-based sequence-to- sequence architecture [Sutskever et al., 2014; Bahdanau et al., 2015] to build our base model. As shown in Figure 2, the base model consists of a question encoder and a grammar- based decoder. For each question, the encoder provides con- textual representations, while the decoder generates its corre- sponding SQL query according to a prede\ufb01ned grammar.",
      "As shown in Figure 2, the base model consists of a question encoder and a grammar- based decoder. For each question, the encoder provides con- textual representations, while the decoder generates its corre- sponding SQL query according to a prede\ufb01ned grammar. Question Encoder To capture contextual information within a question, we ap- ply Bidirectional Long Short-Term Memory Neural Network (BiLSTM) as our question encoder [Hochreiter and Schmid- huber, 1997; Schuster and Paliwal, 1997]. Speci\ufb01cally, at turn i, \ufb01rstly every token xi,k in xi is fed into a word embedding layer \u03c6x to get its embedding representation \u03c6x(xi,k). On top of the embedding representation, the question encoder ob- tains a contextual representation hE i,k = [h \u2212 \u2192 E i,k ; h \u2190 \u2212 E i,k], where the forward hidden state is computed as following: h \u2212 \u2192 E i,k = LSTM \u2212 \u2192 E \u0010 \u03c6x(xi,k), h \u2212 \u2192 E i,k\u22121 \u0011 .",
      "(1) Grammar-based Decoder The decoder is grammar-based with attention on the input question [Krishnamurthy et al., 2017]. Different from pro- ducing a SQL query word by word, our decoder outputs a sequence of grammar rule (i.e. action). Such a sequence has one-to-one correspondence with the abstract syntax tree of the SQL query. Taking the SQL query in Figure 2 as an example,",
      "Different from pro- ducing a SQL query word by word, our decoder outputs a sequence of grammar rule (i.e. action). Such a sequence has one-to-one correspondence with the abstract syntax tree of the SQL query. Taking the SQL query in Figure 2 as an example, it is transformed to the action sequence \u27e8Start\u2192 \u2192 \u2192 \u2192 \u2192 \u2192 \u2026 \u2192 \u2192 \u2026 \u2026 Start \u2192Root | intersect Root Root | union Root Root | except Root Root Root \u2192Select | Select Filter | Select Order | Select Filter Order Select\u2192Agg | Agg Agg | Agg Agg \u22efAgg  Filter\u2192and Filter Filter | or Filter Filter | > Agg | > Agg Root | < Agg | < Agg Root | \u2265Agg | \u2265Agg Root | \u2264Agg | \u2264Agg Root | = Agg | = Agg Root | \u2260Agg | \u2260Agg Root | between Agg | like Agg | not like Agg | in Agg Root | not in Agg Root Order \u2192asc Agg | asc limit Agg | desc Agg | desc limit Agg Agg \u2192none Col Tab | max Col Tab | min Col Tab | count Col Tab | sum Col Tab | avg Col Tab Col  \u2192MakeId | Model | Make | Id | MPG | Horsepower Tab  \u2192CARS_NAMES | CARS_DATA Figure 2: The grammar rule and the abstract syntax tree for the SQL SELECT Id FROM CARS DATA ORDER BY Horsepower DESC LIMIT 1,",
      "along with the framework of our base model. Schema-speci\ufb01c grammar rules change with the database schema. Root, Root\u2192Select Order, Select\u2192Agg, Agg\u2192max Col Tab, Col\u2192 Id, Tab\u2192CARS DATA, Order\u2192desc limit Agg, Agg\u2192none Col Tab, Col\u2192Horsepower, Tab\u2192CARS DATA \u27e9by left-to-right depth-\ufb01rst traversing on the tree. At each decoding step, a nonterminal is expanded using one of its corresponding grammar rules. The rules are either schema-speci\ufb01c (e.g. Col\u2192Horsepower), or schema-agnostic (e.g. Start\u2192Root). More speci\ufb01cally, as shown at the top of Figure 2, we make a little modi\ufb01cation on Order-related rules upon the grammar proposed by Guo et al. [2019], which has been proven to have better performance than vanilla SQL grammar.",
      "More speci\ufb01cally, as shown at the top of Figure 2, we make a little modi\ufb01cation on Order-related rules upon the grammar proposed by Guo et al. [2019], which has been proven to have better performance than vanilla SQL grammar. Denoting LSTM \u2212 \u2192 D the unidirec- tional LSTM used in the decoder, at each decoding step j of turn i, it takes the embedding of the previous generated gram- mar rule \u03c6y(yi,j\u22121) (indicated as the dash lines in Figure 2), and updates its hidden state as: h \u2212 \u2192 D i,j = LSTM \u2212 \u2192 D\u0010 [\u03c6y(yi,j\u22121); ci,j\u22121], h \u2212 \u2192 D i,j\u22121 \u0011 , (2) where ci,j\u22121 is the context vector produced by attending on each encoder hidden state hE i,k in the previous step: ei,k = hE i,k We h \u2212 \u2192 D i,j\u22121, ai,k = exp (ei,k) P k exp(ei,k), ci,j\u22121 = X k hE i,k \u00b7 ai,k, (3) where We is a learned matrix.",
      "h \u2212 \u2192 D i,0 is initialized by the \ufb01- nal encoder hidden state hE i,|xi|, while ci,0 is a zero-vector.",
      "[\ud835\udc31\ud835\udc56\u2212\u210e, \u2026 , \ud835\udc31\ud835\udc56] \ud835\udc32\ud835\udc56 \ud835\udc32\ud835\udc56 \ud835\udc31\ud835\udc56 \ud835\udc31\ud835\udc56\u2212\u210e \u2026 \u2026 \ud835\udc32\ud835\udc56 \ud835\udc31\ud835\udc56 \ud835\udc31\ud835\udc56\u2212\u210e \u2026 Figure 3: Different methods to incorporate recent h questions [xi\u2212h, ..., xi\u22121]. (a) CONCAT: concatenate recent questions with xi as input; (b) TURN: employ a turn-level encoder to capture the inter-dependencies among questions in different turns; (c) GATE: use a gate mechanism to compute the importance of each question. For each schema-agnostic grammar rule, \u03c6y returns a learned embedding. The embedding of a schema-speci\ufb01c grammar rule is obtained by passing its schema (i.e. table or column) through another unidirectional LSTM, namely schema en- coder LSTM \u2212 \u2192 S . For example, the embedding of Col\u2192Id is: \u03c6y(Col\u2192Id) = LSTM \u2212 \u2192 S \u0000\u03c6x(\u201cId\u201d), #\u00bb0 \u0001 .",
      "table or column) through another unidirectional LSTM, namely schema en- coder LSTM \u2212 \u2192 S . For example, the embedding of Col\u2192Id is: \u03c6y(Col\u2192Id) = LSTM \u2212 \u2192 S \u0000\u03c6x(\u201cId\u201d), #\u00bb0 \u0001 . (4) As for the output yi,j, if the expanded nonterminal corre- sponds to schema-agnostic grammar rules, we can obtain the output probability of action \u03b3 as: P(yi,j = \u03b3) \u221dexp \u0000tanh ([h \u2212 \u2192 D i,j; ci,j] Wo) \u03c6y(\u03b3) \u0001 , (5) where Wo is a learned matrix. When it comes to schema- speci\ufb01c grammar rules, the main challenge is that the model may encounter schemas never appeared in training due to the cross-domain setting. To deal with it, we do not directly com- pute the similarity between the decoder hidden state and the schema-speci\ufb01c grammar rule embedding.",
      "To deal with it, we do not directly com- pute the similarity between the decoder hidden state and the schema-speci\ufb01c grammar rule embedding. Instead, we \ufb01rst obtain the unnormalized linking score l(xi,k, \u03b3) between the k-th token in xi and the schema inside action \u03b3. It is com- puted by both handcraft features (e.g. word exact match) [Bogin et al., 2019] and learned similarity (i.e. dot prod- uct between word embedding and grammar rule embedding). With the input question as bridge, we reuse the attention score ai,k in Equation 3 to measure the probability of outputting a schema-speci\ufb01c action \u03b3 as: P(yi,j = \u03b3) \u221dexp \u0000 X k ai,k\u00b7l(xi,k, \u03b3) \u0001 . (6) 2.2 Recent Questions as Context To take advantage of the question context, we provide the base model with recent h questions as additional input. As shown in Figure 3, we summarize and generalize three ways to incorporate recent questions as context. CONCAT.",
      "(6) 2.2 Recent Questions as Context To take advantage of the question context, we provide the base model with recent h questions as additional input. As shown in Figure 3, we summarize and generalize three ways to incorporate recent questions as context. CONCAT. The method concatenates recent questions with the current question in order, making the input of the question encoder be [xi\u2212h, . . . , xi], while the architecture of the base model remains the same. We do not insert special delimiters between questions, as there are punctuation marks. TURN. A dialogue can be seen as a sequence of questions which, in turn, are sequences of words. Considering such hierarchy, Suhr et al. [2018] employed a turn-level encoder (i.e. an unidirectional LSTM) to encode recent questions hi- erarchically. At turn i, it takes the previous question vector hE i\u22121 = [h \u2190 \u2212 E i\u22121,1, h \u2212 \u2192 E i\u22121,|xi\u22121|] as input, and updates its hidden state to h \u2212 \u2192 T i .",
      "At turn i, it takes the previous question vector hE i\u22121 = [h \u2190 \u2212 E i\u22121,1, h \u2212 \u2192 E i\u22121,|xi\u22121|] as input, and updates its hidden state to h \u2212 \u2192 T i . Then h \u2212 \u2192 T i is fed into the question encoder as an implicit context. Accordingly Equation 1 is rewritten: h \u2212 \u2192 E i,k = LSTM \u2212 \u2192 E \u0010 [\u03c6x(xi,k); h \u2212 \u2192 T i ], h \u2212 \u2192 E i,k\u22121 \u0011 . (7) Similar to CONCAT, Suhr et al. [2018] allowed the decoder to attend over all encoder hidden states. To make the de- coder distinguish hidden states from different turns, they fur- ther proposed a relative distance embedding \u03c6d in attention computing.",
      "(7) Similar to CONCAT, Suhr et al. [2018] allowed the decoder to attend over all encoder hidden states. To make the de- coder distinguish hidden states from different turns, they fur- ther proposed a relative distance embedding \u03c6d in attention computing. Taking the above into account, Equation 3 is as: ei\u2212t,k = [hE i\u2212t,k; \u03c6d(t)] We h \u2212 \u2192 D i,j\u22121, ai\u2212t,k = exp (ei\u2212t,k) P t P k exp(ei\u2212t,k), ci,j\u22121 = X t X k[hE i\u2212t,k; \u03c6d(t)] \u00b7 ai\u2212t,k, (8) where t\u2208[0, . . . , h] represents the relative distance. GATE. To jointly model the decoder attention in token-level and question-level, inspired by the advances of open-domain dialogue area [Zhang et al., 2018], we propose a gate mecha- nism to automatically compute the importance of each ques- tion.",
      "GATE. To jointly model the decoder attention in token-level and question-level, inspired by the advances of open-domain dialogue area [Zhang et al., 2018], we propose a gate mecha- nism to automatically compute the importance of each ques- tion. The importance is computed by: gi\u2212t = Vg tanh(UghE i\u2212t + WghE i ), \u00afgi\u2212t = exp(gi\u2212t) P t exp (gi\u2212t), (9) where {Vg, Wg, Ug} are learned parameters and 0 \u2264t \u2264h. As done in Equation 8 except for the relative distance embed- ding, the decoder of GATE also attends over all the encoder hidden states. And the question-level importance \u00afgi\u2212t is em- ployed as the coef\ufb01cient of the attention scores at turn i\u2212t. 2.3 Precedent SQL as Context Besides recent questions, as mentioned in Section 1, the precedent SQL can also be context. As shown in Figure 4, the usage of yi\u22121 requires a SQL encoder, where we employ another BiLSTM to achieve it.",
      "2.3 Precedent SQL as Context Besides recent questions, as mentioned in Section 1, the precedent SQL can also be context. As shown in Figure 4, the usage of yi\u22121 requires a SQL encoder, where we employ another BiLSTM to achieve it. The m-th contextual action representation at turn i\u22121, hA i\u22121,m, can be obtained by pass- ing the action sequence through the SQL encoder. SQL ATTN. Attention over yi\u22121 is a straightforward method to incorporate the SQL context. Given hA i\u22121,m, we employ a similar manner as Equation 3 to compute attention score and thus obtain the SQL context vector. This vector is employed as an additional input for decoder in Equation 2. ACTION COPY. To reuse the precedent generated SQL, Zhang et al. [2019] presented a token-level copy mechanism on their non-grammar based parser. Inspired by them, we propose an action-level copy mechanism suited for grammar- based decoding. It enables the decoder to copy actions ap- pearing in yi\u22121, when the actions are compatible to the cur- rent expanded nonterminal. As the copied actions lie in the",
      "Decoder \ud835\udc66\ud835\udc56,\ud835\udc57 Encoder \ud835\udc31\ud835\udc56 \ud835\udc32\ud835\udc56\u22121 SQL Enc. Attention Decoder Encoder \ud835\udc31\ud835\udc56 Gen. \ud835\udc32\ud835\udc56\u22121 Copy \ud835\udc66\ud835\udc56,\ud835\udc57 SQL Enc. Decoder Encoder \ud835\udc31\ud835\udc56 Gen. Copy SQL Enc. \ud835\udc32\ud835\udc56\u22121 Gen. \ud835\udc66\ud835\udc56,\ud835\udc57 Attention Attention Tree Ext. Figure 4: Different methods to employ the precedent SQL yi\u22121. SQL Enc. is short for SQL Encoder, Tree Ext. for Subtree Extractor, and Gen. for Generate. (a) SQL ATTN: attending over yi\u22121; (b) ACTION COPY: allow to copy actions from yi\u22121; (c) TREE COPY: allow to copy action subtrees extracted from yi\u22121. same semantic space with the generated ones, the output probability for action \u03b3 is a mix of generating (g) and copy- ing (c).",
      "same semantic space with the generated ones, the output probability for action \u03b3 is a mix of generating (g) and copy- ing (c). The generating probability P(yi,j = \u03b3 | g) follows Equation 5 and 6, while the copying probability is: P(yi,j =\u03b3|c) \u221dP m1[\u03b3 =yi\u22121,m]\u00b7 exp(h \u2212 \u2192 D i,jWlhA i\u22121,m), (10) where Wl is a learned matrix. Denoting P copy i,j the proba- bility of copying at decoding step j of turn i, it can be ob- tained by \u03c3(Wch \u2212 \u2192 D i,j + bc), where {Wc, bc} are learned pa- rameters and \u03c3 is the sigmoid function. The \ufb01nal probability P(yi,j = \u03b3) is computed by: P copy i,j \u00b7 P(yi,j = \u03b3 | c)+(1\u2212P copy i,j ) \u00b7 P(yi,j = \u03b3 | g). (11) TREE COPY. Besides the action-level copy, we also intro- duce a tree-level copy mechanism.",
      "(11) TREE COPY. Besides the action-level copy, we also intro- duce a tree-level copy mechanism. As illustrated in Figure 4, tree-level copy mechanism enables the decoder to copy ac- tion subtrees extracted from yi\u22121, which shrinks the num- ber of decoding steps by a large margin. Similar idea has been proposed in a non-grammar based decoder [Suhr et al., 2018]. In fact, a subtree is an action sequence starting from speci\ufb01c nonterminals, such as Select. To give an example, \u27e8Select\u2192Agg, Agg\u2192max Col Tab, Col\u2192Id, Tab\u2192CARS DATA \u27e9 makes up a subtree for the tree in Figure 2. For a subtree \u03c5, its representation \u03c6t(\u03c5) is the \ufb01nal hidden state when feed- ing its corresponding action sequence into the SQL encoder. Then we can obtain the output probability of subtree \u03c5 as: P(yi,j = \u03c5) \u221dexp \u0000h \u2212 \u2192 D i,jWt\u03c6t(\u03c5) \u0001 , (12) where Wt is a learned matrix.",
      "Then we can obtain the output probability of subtree \u03c5 as: P(yi,j = \u03c5) \u221dexp \u0000h \u2212 \u2192 D i,jWt\u03c6t(\u03c5) \u0001 , (12) where Wt is a learned matrix. The output probabilities of subtrees are normalized together with Equation 5 and 6. 2.4 BERT Enhanced Embedding We employ BERT [Devlin et al., 2019] to augment our model via enhancing the embedding of questions and schemas. We \ufb01rst concatenate the input question and all the schemas in a deterministic order with [SEP] as delimiter [Hwang et al., 2019]. For instance, the input for Q1 in Figure 1 is \u201cWhat is id ... max horsepower? [SEP] CARS DATA ... [SEP] Make\u201d. Feeding it into BERT, we obtain the schema-aware question representations and question-aware schema representations. These contextual representations are used to substitute \u03c6x subsequently, while other parts of the model remain the same.",
      "[SEP] CARS DATA ... [SEP] Make\u201d. Feeding it into BERT, we obtain the schema-aware question representations and question-aware schema representations. These contextual representations are used to substitute \u03c6x subsequently, while other parts of the model remain the same. Model SParC CoSQL Ques.Match Int.Match Ques.Match Int.Match SyntaxSQL-con 18.5 4.3 15.1 2.7 CD-Seq2Seq 21.9 8.1 13.8 2.1 EditSQL 33.0 16.4 22.2 5.8 Ours 41.8 20.6 33.5 9.6 EditSQL + BERT 47.2 29.5 40.0 11.0 Ours + BERT 52.6 29.9 41.0 14.0 Table 1: We report the best performance observed in 5 runs on the development sets of both SPARC and COSQL, since their test sets are not public.",
      "We also conduct Wilcoxon signed-rank tests between our method and the baselines, and the bold results show the improve- ments of our model are signi\ufb01cant with p < 0.005. 3 Experiment & Analysis We conduct experiments to study whether the introduced methods are able to effectively model context in the task of SPC (Section 3.2), and further perform a \ufb01ne-grained analy- sis on various contextual phenomena (Section 3.3). 3.1 Experimental Setup Dataset. Two large complex cross-domain datasets are used: SPARC [Yu et al., 2019b] consists of 3034 / 422 dia- logues for train / development, and COSQL [Yu et al., 2019a] consists of 2164 / 292 ones. The average turn numbers of SPARC and COSQL are 3.0 and 5.2, respectively. Evaluation Metrics. We evaluate predicted SQL queries using exact set match accuracy [Yu et al., 2019b].",
      "The average turn numbers of SPARC and COSQL are 3.0 and 5.2, respectively. Evaluation Metrics. We evaluate predicted SQL queries using exact set match accuracy [Yu et al., 2019b]. Based on it, we consider three metrics: Question Match (Ques.Match), the match accuracy over all questions, Interaction Match (Int.Match), the match accuracy over all dialogues1, and Turn i Match, the match accuracy over questions at turn i. Implementation Detail. Our implementation is based on PyTorch [Paszke et al., 2017], AllenNLP [Gardner et al., 2018] and the library transformers [Wolf et al., 2019]. We adopt the Adam optimizer and set the learning rate as 1e-3 on all modules except for BERT, for which a learning rate of 1e-5 is used [Kingma and Ba, 2015]. The dimensions of word embedding, action embedding and distance embedding are 100, while the hidden state dimensions of question en- coder, grammar-based decoder, turn-level encoder and SQL encoder are 200.",
      "The dimensions of word embedding, action embedding and distance embedding are 100, while the hidden state dimensions of question en- coder, grammar-based decoder, turn-level encoder and SQL encoder are 200. We initialize word embedding using GloVe [Pennington et al., 2014] for non-BERT models. For methods that use recent h questions, h is set as 5 on both datasets. Baselines. We consider three models as our baselines. SyntaxSQL-con and CD-Seq2Seq are two strong baselines introduced in the SPARC dataset paper [Yu et al., 2019b]. SyntaxSQL-con employs a BiLSTM model to encode dia- logue history upon the SyntaxSQLNet model (analogous to our TURN) [Yu et al., 2018], while CD-Seq2Seq is adapted from Suhr et al. [2018] for cross-domain settings (analogous to our TURN+TREE COPY). EditSQL [Zhang et al., 2019] is a STOA baseline which mainly makes use of SQL at- tention and token-level copy (analogous to our TURN+SQL ATTN+ACTION COPY).",
      "EditSQL [Zhang et al., 2019] is a STOA baseline which mainly makes use of SQL at- tention and token-level copy (analogous to our TURN+SQL ATTN+ACTION COPY). 1Int.Match is much more challenging as it requires each pre- dicted SQL in a dialogue to be correct.",
      "Question Interaction Turn1 (422) Turn2 (422) Turn3 (270) \u2265Turn4 (89) SParC 40.0 2.4 -1.7 -1.6 -7.6 -10.8 -0.3 -1.5 -0.4 0.3 -3.1 -0.2 -0.3 18.3 1.8 -2.5 1.1 -6.0 -9.8 1.0 -1.4 0.1 2.0 -1.9 0.4 1.9 55.0 0.9 -1.3 -2.7 -3.1 -0.8 -0.9 -0.8 0.9 -0.5 -2.1 0.7 -0.7 36.2 3.5 -1.1 -1.5 -8.6 -16.1 0.5 -0.2 0.2 0.9 -1.7 1.0 0.4 27.6 3.0 -3.5 0.5 -11.",
      "5 -1.1 -1.5 -8.6 -16.1 0.5 -0.2 0.2 0.9 -1.7 1.0 0.4 27.6 3.0 -3.5 0.5 -11.7 -16.0 0.4 -3.8 -3.2 1.1 -6.0 -2.2 0.9 24.7 0.7 -1.3 -4.5 -11.9 -17.1 -3.6 -4.5 -0.4 -1.3 -5.8 -4.7 -4.9 Absolute Improvement over Concat Concat Turn Gate Action Copy Tree Copy SQL Attn Concat + Action Copy Concat + Tree Copy Concat + SQL Attn Turn + Action Copy Turn + Tree Copy Turn + SQL Attn Turn + SQL Attn + Action Copy Question Interaction Turn1 (292) Turn2 (283) Turn3 (244) \u2265Turn4 (185) CoSQL 32.4 -1.1 -6.4 -0.9 -5.7 -4.6 -0.3 -4.",
      "4 -1.1 -6.4 -0.9 -5.7 -4.6 -0.3 -4.6 -2.1 -1.3 -5.4 -1.7 -0.5 9.1 -0.5 -3.4 -1.2 -2.9 -3.2 0.0 -1.7 -1.3 -1.1 -2.2 -1.3 -0.2 40.8 -0.6 -3.9 -1.8 -1.2 -0.7 0.0 -1.1 -0.4 0.6 -2.6 -1.3 0.7 29.5 -0.9 -4.8 -0.2 -5.2 -7.2 -0.3 -4.1 -2.3 -1.5 -4.6 -1.2 0.4 28.3 -1.6 -8.8 -0.9 -8.6 -4.2 -0.5 -6.5 -2.5 -2.4 -6.9 -1.9 -3.",
      "5 -4.6 -1.2 0.4 28.3 -1.6 -8.8 -0.9 -8.6 -4.2 -0.5 -6.5 -2.5 -2.4 -6.9 -1.9 -3.3 29.1 -1.7 -10.0 -0.8 -9.7 -7.3 -0.7 -8.7 -3.9 -2.6 -9.2 -2.7 -0.5 Figure 5: Question Match, Interaction Match and Turn i Match on SPARC and COSQL development sets. The numbers are averaged over 5 runs. The \ufb01rst column represents absolute values. The rest are improvements of different context modeling methods over CONCAT. 3.2 Model Comparison Taking CONCAT as a representative, we compare the perfor- mance of our model with other models, as shown in Table 1. As illustrated, our model outperforms baselines by a large margin with or without BERT, achieving new SOTA perfor- mances on both datasets.",
      "As illustrated, our model outperforms baselines by a large margin with or without BERT, achieving new SOTA perfor- mances on both datasets. Compared with the previous SOTA without BERT on SPARC, our model improves Ques.Match and Int.Match by 8.8 and 4.2 points, respectively. To conduct a thorough comparison, we evaluate 13 differ- ent context modeling methods upon the same parser, includ- ing 6 methods introduced in Section 2 and 7 selective combi- nations of them (e.g., CONCAT+ACTION COPY). The exper- imental results are presented in Figure 5. Taken as a whole, it is very surprising to observe that none of these methods can be consistently superior to the others. The experimental results on BERT-based models show the same trend. Diving deep into the methods only using recent questions as con- text, we observe that CONCAT and TURN perform competi- tively, outperforming GATE by a large margin. With respect to the methods only using precedent SQL as context, ACTION COPY signi\ufb01cantly surpasses TREE COPY and SQL ATTN in all metrics.",
      "With respect to the methods only using precedent SQL as context, ACTION COPY signi\ufb01cantly surpasses TREE COPY and SQL ATTN in all metrics. In addition, we observe that there is little dif- ference in the performance of ACTION COPY and CONCAT, which implies that using precedent SQL as context gives al- most the same effect with using recent questions. In terms of the combinations of different context modeling methods, they do not signi\ufb01cantly improve the performance as we expected. As mentioned in Section 1, intuitively, methods which only use the precedent SQL enjoy better generalizability. To vali- date it, we further conduct an out-of-distribution experiment to assess the generalizability of different context modeling methods. Concretely, we select three representative methods and train them on questions at turn 1 and 2, whereas test them at turn 3, 4 and beyond.",
      "Concretely, we select three representative methods and train them on questions at turn 1 and 2, whereas test them at turn 3, 4 and beyond. As shown in Figure 6, ACTION Turn 3 \u2265Turn 4 (a) Performance on SParC 0 10 20 SQL Exact Set Match Concat Turn Action Copy Turn 3 \u2265Turn 4 (b) Performance on CoSQL Figure 6: Out-of-distribution experimental results (Turn i Match) of three models on SPARC and COSQL development sets. COPY has a consistently comparable or better performance, validating the intuition. Meanwhile, CONCAT appears to be strikingly competitive, demonstrating it also has a good gen- eralizability. Compared with them, TURN is more vulnerable to out-of-distribution questions. In conclusion, existing con- text modeling methods in the task of SPC are not as effective as expected, since they do not show a signi\ufb01cant advantage over the simple concatenation method. 3.3 Fine-grained Analysis By a careful investigation on contextual phenomena, we sum- marize them in multiple hierarchies.",
      "3.3 Fine-grained Analysis By a careful investigation on contextual phenomena, we sum- marize them in multiple hierarchies. Roughly, there are three kinds of contextual phenomena in questions: semantically complete, coreference and ellipsis. Semantically complete means a question can re\ufb02ect all the meaning of its corre- sponding SQL. Coreference means a question contains pro- nouns, while ellipsis means the question cannot re\ufb02ect all of its SQL, even if resolving its pronouns. In the \ufb01ne-grained level, coreference can be divided into 5 types according to its pronoun [Androutsopoulos et al., 1995]. Ellipsis can be characterized by its intention: continuation and substitution2. Continuation is to augment extra semantics (e.g. Filter), and substitution refers to the situation where current question is intended to substitute particular semantics in the precedent question. Substitution can be further branched into 4 types: explicit vs. implicit and schema vs. operator. Explicit means the current question provides contextual clues (i.e.",
      "Filter), and substitution refers to the situation where current question is intended to substitute particular semantics in the precedent question. Substitution can be further branched into 4 types: explicit vs. implicit and schema vs. operator. Explicit means the current question provides contextual clues (i.e. partial context overlaps with the precedent question) to help locate the substitution target, while implicit does not. In most cases, the target is schema or operator. In order to study the ef- fect of context modeling methods on various phenomena, as shown in Table 2, we take the development set of SPARC as an example to perform our analysis. The analysis begins by presenting Ques.Match of three representative models on the above \ufb01ne-grained types in Figure 7. As shown, though different methods have different strengths, they all perform poorly on certain types, which will be elaborated below. Coreference. Diving deep into the coreference (left of Fig- ure 7), we observe that all methods struggle with two \ufb01ne- grained types: de\ufb01nite noun phrases and one anaphora.",
      "Coreference. Diving deep into the coreference (left of Fig- ure 7), we observe that all methods struggle with two \ufb01ne- grained types: de\ufb01nite noun phrases and one anaphora. Through our study, we \ufb01nd the scope of antecedent is a key factor. An antecedent is one or more entities referred by a 2The \ufb01ne-grained types of ellipsis are proposed by us because there is no consensus yet.",
      "Contextual Phenomena Fine-grained Types Count Example Precedent Question Current Question Semantically Complete Context Independent 149 Show the nationality of each person. Group people by their nationality. Coreference Bridging Anaphora 31 Show the version number for all templates. What is the smallest value? De\ufb01nite Noun Phrases 67 Which country has a head of state named Beatrix? What languages are spoken in that country? One Anaphora 59 Order the pets by age. How much does each one weigh? Demonstrative Pronoun 195 Which students have pets? Of those, whose last name is smith? Possessive Determiner 88 How many highschoolers are liked by someone else? What are their names? Ellipsis Continuation 131 What are all the \ufb02ight numbers? Which land in Aberdeen? Substitution Explicit 61 What is id of the car with the max horsepower? How about with the max MPG? Implicit 60 Find the names of museums opened before 2010. How about after? Schema 80 How many losers participated in the Australian Open? Winners?",
      "Substitution Explicit 61 What is id of the car with the max horsepower? How about with the max MPG? Implicit 60 Find the names of museums opened before 2010. How about after? Schema 80 How many losers participated in the Australian Open? Winners? Operator 41 Who was the last student to register? Who was the \ufb01rst to register? Table 2: Different \ufb01ne-grained types, their count and representative examples from the SPARC development set. one means one is a pronoun. Winners means Winners is a phrase intended to substitute losers. Context Independent Bridging Anaphora De\ufb01nite Noun Phrases One Anaphora Demonstrative Pronoun Possessive Determiner Substitution Continuation Schema (Substitution) Operator (Substitution) Explicit (Substitution) Implicit (Substitution) 10 20 30 40 50 Concat Turn Action Copy Figure 7: The average Ques.Match (across 5 runs) of different con- text modeling methods on \ufb01ne-grained types. pronoun.",
      "pronoun. Its scope is either whole, where the antecedent is the precedent answer, or partial, where the antecedent is part of the precedent question. The above-mentioned \ufb01ne- grained types are more challenging as their partial proportion are nearly 40%, while for demonstrative pronoun it is only 22%. It is reasonable as partial requires complex inference on context. Considering the 4th example in Table 2, \u201cone\u201d refers to \u201cpets\u201d instead of \u201cage\u201d because the accompanying verb is \u201cweigh\u201d. From this observation, we draw the conclu- sion that current context modeling methods do not succeed on pronouns which require complex inference on context. Ellipsis. As for ellipsis (right of Figure 7), we obtain some \ufb01ndings by comparisons in three aspects. The \ufb01rst \ufb01nding is that all models have a better performance on continuation than substitution. This is expected since there are redundant semantics in substitution, while not in continuation. Consid- ering the 8th example in Table 2, \u201chorsepower\u201d is redundant and it may raise noise in SQL prediction.",
      "This is expected since there are redundant semantics in substitution, while not in continuation. Consid- ering the 8th example in Table 2, \u201chorsepower\u201d is redundant and it may raise noise in SQL prediction. The second \ufb01nding comes from the unexpected drop from implicit(substitution) to explicit(substitution). Intuitively, explicit should surpass implicit on substitution as it provides more contextual clues. The \ufb01nding demonstrates that contextual clues are obviously not well utilized by the context modeling methods. Third, compared with schema(substitution), operator(substitution) achieves a comparable or better performance consistently. We believe it is caused by the cross-domain setting, which makes schema related substitution more dif\ufb01cult. 4 Related Work The most related work is the line of semantic parsing in con- text. In the topic of SQL, Zettlemoyer and Collins [2009] proposed a context-independent CCG parser and then applied it to do context-dependent substitution, Iyyer et al. [2017] applied a search-based method for sequential questions, and Suhr et al. [2018] provided the \ufb01rst sequence-to-sequence so- lution in the area.",
      "[2017] applied a search-based method for sequential questions, and Suhr et al. [2018] provided the \ufb01rst sequence-to-sequence so- lution in the area. More recently, Zhang et al. [2019] pre- sented a edit-based method to reuse the precedent generated SQL, while Liu et al. [2019] introduced an auxiliary task. With respect to other logic forms, Long et al. [2016] focused on understanding execution commands in context, Guo et al. [2018] on question answering over knowledge base in a conversation, and [Iyer et al., 2018] on code generation in environment context. Our work is different from theirs as we perform an exploratory study, not ful\ufb01lled by previous works. There are also several related works that provided stud- ies on context. Hwang et al. [2019] explored the contex- tual representations in context-independent semantic parsing, and Sankar et al. [2019] studied how conversational agents use conversation history to generate response. Different from them, our task focuses on context modeling for semantic pars- ing.",
      "[2019] explored the contex- tual representations in context-independent semantic parsing, and Sankar et al. [2019] studied how conversational agents use conversation history to generate response. Different from them, our task focuses on context modeling for semantic pars- ing. Under the same task, Androutsopoulos et al. [1995] summarized contextual phenomena in a coarse-grained level, while Bertomeu et al. [2006] performed a Wizard-of-Oz ex- periment to study the most frequent phenomena. What makes our work different from them is that we not only summarize contextual phenomena by \ufb01ne-grained types, but also perform an analysis of context modeling methods. 5 Conclusion & Future Work This work conducts an exploratory study on semantic parsing in context, to realize how far we are from effective context modeling. Through a thorough comparison, we \ufb01nd that ex- isting context modeling methods are not as effective as ex- pected. A simple concatenation method can be much com- petitive.",
      "Through a thorough comparison, we \ufb01nd that ex- isting context modeling methods are not as effective as ex- pected. A simple concatenation method can be much com- petitive. Furthermore, by performing a \ufb01ne-grained analysis, we summarize two potential directions as our future work: in- corporating common sense for better pronouns inference, and modeling contextual clues in a more explicit manner. We be- lieve our work can facilitate the community to debug models in a \ufb01ne-grained level and make more progress.",
      "References [Androutsopoulos et al., 1995] Ion Androutsopoulos, Graeme D Ritchie, and Peter Thanisch. Natural Lan- guage Interfaces to Databases\u2013An Introduction. Natural language engineering, 1995. [Bahdanau et al., 2015] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to align and translate. In ICLR, 2015. [Bertomeu et al., 2006] N\u00b4uria Bertomeu, Hans Uszkoreit, Anette Frank, Hans-Ulrich Krieger, and Brigitte J\u00a8org. Contextual phenomena and thematic relations in database QA dialogues: results from a wizard-of-Oz experiment. In NAACL, 2006. [Bogin et al., 2019] Ben Bogin, Jonathan Berant, and Matt Gardner. Representing schema structure with graph neural networks for text-to-SQL parsing. In ACL, 2019.",
      "In NAACL, 2006. [Bogin et al., 2019] Ben Bogin, Jonathan Berant, and Matt Gardner. Representing schema structure with graph neural networks for text-to-SQL parsing. In ACL, 2019. [Devlin et al., 2019] Jacob Devlin, Ming-Wei Chang, Ken- ton Lee, and Kristina Toutanova. BERT: Pre-training of deep bidirectional transformers for language understand- ing. In NAACL, 2019. [Gardner et al., 2018] Matt Gardner, Joel Grus, Mark Neu- mann, Oyvind Tafjord, Pradeep Dasigi, Nelson F. Liu, Matthew Peters, Michael Schmitz, and Luke Zettlemoyer. AllenNLP: A deep semantic natural language processing platform. In ACL, 2018. [Guo et al., 2018] Daya Guo, Duyu Tang, Nan Duan, Ming Zhou, and Jian Yin. Dialog-to-action: conversational ques- tion answering over a large-scale knowledge base. In NIPS, 2018.",
      "[Guo et al., 2018] Daya Guo, Duyu Tang, Nan Duan, Ming Zhou, and Jian Yin. Dialog-to-action: conversational ques- tion answering over a large-scale knowledge base. In NIPS, 2018. [Guo et al., 2019] Jiaqi Guo, Zecheng Zhan, Yan Gao, Yan Xiao, Jian-Guang Lou, Ting Liu, and Dongmei Zhang. To- wards complex text-to-SQL in cross-domain database with intermediate representation. In ACL, 2019. [Hochreiter and Schmidhuber, 1997] Sepp Hochreiter and J\u00a8urgen Schmidhuber. Long short-term memory. Neural Computation, Volume 9, 1997. [Hwang et al., 2019] Wonseok Hwang, Jinyeung Yim, Se- unghyun Park, and Minjoon Seo. A comprehensive explo- ration on wikisql with table-aware word contextualization. arXiv, 2019.",
      "[Hwang et al., 2019] Wonseok Hwang, Jinyeung Yim, Se- unghyun Park, and Minjoon Seo. A comprehensive explo- ration on wikisql with table-aware word contextualization. arXiv, 2019. [Iyer et al., 2018] Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, and Luke Zettlemoyer. Mapping language to code in programmatic context. In EMNLP, 2018. [Iyyer et al., 2017] Mohit Iyyer, Wen-tau Yih, and Ming-Wei Chang. Search-based neural structured learning for se- quential question answering. In ACL, 2017. [Kingma and Ba, 2015] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015. [Krishnamurthy et al., 2017] Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gardner. Neural semantic parsing with type constraints for semi-structured tables.",
      "Adam: A method for stochastic optimization. In ICLR, 2015. [Krishnamurthy et al., 2017] Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gardner. Neural semantic parsing with type constraints for semi-structured tables. In EMNLP, 2017. [Lin et al., 2019] Kevin Lin, Ben Bogin, Mark Neumann, Jonathan Berant, and Matt Gardner. Grammar-based neu- ral text-to-SQL generation. CoRR, 2019. [Liu et al., 2019] Qian Liu, Bei Chen, Haoyan Liu, Jian- Guang Lou, Lei Fang, Bin Zhou, and Dongmei Zhang. A split-and-recombine approach for follow-up query analy- sis. In EMNLP-IJCNLP, 2019. [Long et al., 2016] Reginald Long, Panupong Pasupat, and Percy Liang. Simpler context-dependent logical forms via model projections. In ACL, 2016.",
      "In EMNLP-IJCNLP, 2019. [Long et al., 2016] Reginald Long, Panupong Pasupat, and Percy Liang. Simpler context-dependent logical forms via model projections. In ACL, 2016. [Paszke et al., 2017] Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary De- Vito, Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in PyTorch. In NIPS, 2017. [Pennington et al., 2014] Jeffrey Pennington, Richard Socher, and Christopher D. Manning. GloVe: Global vectors for word representation. In EMNLP, 2014. [Sankar et al., 2019] Chinnadhurai Sankar, Sandeep Subra- manian, Chris Pal, Sarath Chandar, and Yoshua Bengio. Do neural dialog systems use the conversation history ef- fectively? an empirical study. 2019.",
      "Do neural dialog systems use the conversation history ef- fectively? an empirical study. 2019. [Schuster and Paliwal, 1997] Mike Schuster and Kuldip K. Paliwal. Bidirectional recurrent neural networks. IEEE Trans. Signal Processing, Volume 45, 1997. [Suhr et al., 2018] Alane Suhr, Srinivasan Iyer, and Yoav Artzi. Learning to map context-dependent sentences to executable formal queries. In NAACL, 2018. [Sutskever et al., 2014] Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. Sequence to sequence learning with neural networks. In NIPS, 2014. [Wolf et al., 2019] Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement Delangue, Anthony Moi, Pierric Cistac, Tim Rault, R\u2019emi Louf, Morgan Fun- towicz, and Jamie Brew. Huggingface\u2019s transformers: State-of-the-art natural language processing.",
      "Huggingface\u2019s transformers: State-of-the-art natural language processing. arXiv, 2019. [Yin and Neubig, 2018] Pengcheng Yin and Graham Neu- big. TRANX: A transition-based neural abstract syn- tax parser for semantic parsing and code generation. In EMNLP, 2018. [Yu et al., 2018] Tao Yu, Michihiro Yasunaga, Kai Yang, Rui Zhang, Dongxu Wang, Zifan Li, and Dragomir Radev. SyntaxSQLNet: Syntax tree networks for complex and cross-domain text-to-SQL task. In EMNLP, 2018.",
      "SyntaxSQLNet: Syntax tree networks for complex and cross-domain text-to-SQL task. In EMNLP, 2018. [Yu et al., 2019a] Tao Yu, Rui Zhang, Heyang Er, Suyi Li, Eric Xue, Bo Pang, Xi Victoria Lin, Yi Chern Tan, Tianze Shi, Zihan Li, Youxuan Jiang, Michihiro Yasunaga, Sungrok Shim, Tao Chen, Alexander Fabbri, Zifan Li, Luyao Chen, Yuwen Zhang, Shreya Dixit, Vincent Zhang, Caiming Xiong, Richard Socher, Walter Lasecki, and Dragomir Radev. CoSQL: A conversational text-to-SQL challenge towards cross-domain natural language inter- faces to databases. In EMNLP-IJCNLP, 2019. [Yu et al., 2019b] Tao Yu, Rui Zhang, Michihiro Yasunaga, Yi Chern Tan, Xi Victoria Lin, Suyi Li, Heyang Er, Irene",
      "Li, Bo Pang, Tao Chen, Emily Ji, Shreya Dixit, David Proctor, Sungrok Shim, Jonathan Kraft, Vincent Zhang, Caiming Xiong, Richard Socher, and Dragomir Radev. SParC: Cross-domain semantic parsing in context. In ACL, 2019. [Zettlemoyer and Collins, 2009] Luke S. Zettlemoyer and Michael Collins. Learning context-dependent mappings from sentences to logical form. In ACL-IJNLP, 2009. [Zhang et al., 2018] Weinan Zhang, Yiming Cui, Yifa Wang, Qingfu Zhu, Lingzhi Li, Lianqiang Zhou, and Ting Liu. Context-sensitive generation of open-domain conversa- tional responses. In COLING, 2018. [Zhang et al., 2019] Rui Zhang, Tao Yu, Heyang Er, Sungrok Shim, Eric Xue, Xi Victoria Lin, Tianze Shi, Caiming Xiong, Richard Socher, and Dragomir Radev. Editing- based SQL query generation for cross-domain context- dependent questions.",
      "Editing- based SQL query generation for cross-domain context- dependent questions. In EMNLP-IJCNLP, 2019."
    ],
    "queries":"/future/u/okhattab/data/MSMARCO/queries.train.tsv",
    "index_name":"PaperTab-question-2002.00652.pdf",
    "overwrite":false,
    "root":".ragatouille/",
    "experiment":"colbert",
    "index_root":null,
    "name":"2025-05/17/10.22.50",
    "rank":0,
    "nranks":1,
    "amp":true,
    "gpus":1,
    "avoid_fork_if_possible":false
  },
  "num_chunks":1,
  "num_partitions":1024,
  "num_embeddings":10076,
  "avg_doclen":170.7796610169,
  "RAGatouille":{
    "index_config":{
      "index_type":"PLAID",
      "index_name":"PaperTab-question-2002.00652.pdf"
    }
  }
}